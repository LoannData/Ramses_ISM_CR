subroutine output_patch(filename)
  character(LEN=80)::filename
  character(LEN=80)::fileloc
  character(LEN=30)::format
  integer::ilun

  ilun=11

  fileloc=TRIM(filename)
  format="(A)"
  open(unit=ilun,file=fileloc,form='formatted')
  write(ilun,format)"../patch/collapse/condinit.f90"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine condinit(x,u,dx,nn)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH  "
  write(ilun,format)"  use units_commons"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer ::nn                              ! Number of cells"
  write(ilun,format)"  real(dp)::dx                              ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x   ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates initial conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:4): d.u,d.v,d.w, U(i,5): E, U(i,6:8): Bleft, "
  write(ilun,format)"  ! U(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! Q is the primitive variable vector. Conventions are here:"
  write(ilun,format)"  ! Q(i,1): d, Q(i,2:4):u,v,w, Q(i,5): P, Q(i,6:8): Bleft, "
  write(ilun,format)"  ! Q(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! If nvar > 8, remaining variables (9:nvar) are treated as passive"
  write(ilun,format)"  ! scalars in the hydro solver."
  write(ilun,format)"  ! U(:,:) and Q(:,:) are in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::ivar"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::q   ! Primitive variables"
  write(ilun,format)""
  write(ilun,format)"  integer :: i,j,k,id,iu,iv,iw,ip,igroup"
  write(ilun,format)"  real(dp):: x0,y0,z0,rc,rs,xx,yy,zz,pi,r0,d0,B0,p0,omega0,radiation_source,mass"
  write(ilun,format)"  integer :: np"
  write(ilun,format)"  real(dp)::Temp"
  write(ilun,format)"  "
  write(ilun,format)"  logical,save:: first=.true."
  write(ilun,format)"  real(dp),dimension(1:3,1:100,1:100,1:100),save::q_idl"
  write(ilun,format)"  real(dp),save::vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot"
  write(ilun,format)"  integer,save:: n_size"
  write(ilun,format)"  integer:: ind_i, ind_j, ind_k"
  write(ilun,format)"  real(dp),save:: d_c,B_c,ind,seed1,seed2,seed3,xi,yi,zi,zeta"
  write(ilun,format)"  real(dp),save:: res_int,r_0,C_s,omega,v_rms,cont_ic,mass_total,mass_tot2,min_col_d,max_col_d"
  write(ilun,format)"  real(dp):: col_d,eli,sph,vx,vy,vz"
  write(ilun,format)"  real(dp)::xl,yl,zl,bx,by,bz,dxmin"
  write(ilun,format)"  integer:: ii,jj,kk,nticks"
  write(ilun,format)"  integer, save :: count_vrms"
  write(ilun,format)"  real(dp)::ener_rot,ener_grav,ener_therm,ener_grav2,ener_turb,dd,ee,theta_mag_radians"
  write(ilun,format)"  real(dp),dimension(1000):: mass_rad    "
  write(ilun,format)"  real(dp),dimension(1:3,1:3):: rot_M,rot_invM,rot_tilde"
  write(ilun,format)""
  write(ilun,format)"  small_er=eray_min/(scale_d*scale_v**2)"
  write(ilun,format)""
  write(ilun,format)"  id=1; iu=2; iv=3; iw=4; ip=5"
  write(ilun,format)"  x0=0.5*boxlen"
  write(ilun,format)"  y0=0.5*boxlen"
  write(ilun,format)"  z0=0.5*boxlen"
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)"  theta_mag_radians = theta_mag/180.0d0*pi"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(bb_test)then"
  write(ilun,format)"     ! cloud radius equal to unity"
  write(ilun,format)"     r0=(alpha*2.*6.67d-8*mass_c*scale_m*mu_gas*mH/(5.*kB*Tr_floor))/scale_l"
  write(ilun,format)"     ! cloud density equal to unity"
  write(ilun,format)"     d0 = 3.0d0*mass_c/(4.0d0*pi*r0**3.)"
  write(ilun,format)"     ! threshold for ambipolar fluxes"
  write(ilun,format)"     !rho_threshold = d0/10.d0"
  write(ilun,format)"     ! cloud rotation"
  write(ilun,format)"     omega0 = sqrt(beta*4.*pi*d0)"
  write(ilun,format)""
  write(ilun,format)"     rot_M(1,1:3) = (/cos(theta_mag_radians),0.0d0,-sin(theta_mag_radians)/)"
  write(ilun,format)"     rot_M(2,1:3) = (/0.0d0,1.0d0,0.0d0/)"
  write(ilun,format)"     rot_M(3,1:3) = (/sin(theta_mag_radians),0.0d0,cos(theta_mag_radians)/)"
  write(ilun,format)""
  write(ilun,format)"     rot_invM(1,1:3) = (/cos(theta_mag_radians),0.0d0,sin(theta_mag_radians)/)"
  write(ilun,format)"     rot_invM(2,1:3) = (/0.0d0,1.0d0,0.0d0/)"
  write(ilun,format)"     rot_invM(3,1:3) = (/-sin(theta_mag_radians),0.0d0,cos(theta_mag_radians)/)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     rot_tilde(1,1:3) = (/0.0d0,1.0d0,0.0d0/)"
  write(ilun,format)"     rot_tilde(2,1:3) = (/-1.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"     rot_tilde(3,1:3) = (/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)""
  write(ilun,format)"     ! sound speed"
  write(ilun,format)"     Temp = Tr_floor"
  write(ilun,format)"     C_s = sqrt( Temp / scale_T2 )"
  write(ilun,format)""
  write(ilun,format)"     ! turbulence"
  write(ilun,format)"     if( first) then "
  write(ilun,format)"        vx_tot=0.d0"
  write(ilun,format)"        vy_tot=0.d0"
  write(ilun,format)"        vz_tot=0.d0"
  write(ilun,format)"        vx2_tot=0.d0"
  write(ilun,format)"        vy2_tot=0.d0"
  write(ilun,format)"        vz2_tot=0.d0"
  write(ilun,format)"        v_rms=0.d0 "
  write(ilun,format)"        count_vrms=0"
  write(ilun,format)"        if(Mach .ne. 0)then"
  write(ilun,format)"           if (myid==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'"
  write(ilun,format)"           open(20,file='init_turb.data',form='formatted')"
  write(ilun,format)"           read(20,*) n_size, ind, seed1,seed2,seed3"
  write(ilun,format)"           if(n_size .ne. 100) then"
  write(ilun,format)"              write(*,*) 'Unextected field size'"
  write(ilun,format)"              stop"
  write(ilun,format)"           endif"
  write(ilun,format)"           do k=1,n_size"
  write(ilun,format)"              do j=1,n_size"
  write(ilun,format)"                 do i=1,n_size"
  write(ilun,format)"                    read(20,*)xi,yi,zi,vx,vy,vz"
  write(ilun,format)"                    q_idl(1,i,j,k) = vx"
  write(ilun,format)"                    q_idl(2,i,j,k) = vy"
  write(ilun,format)"                    q_idl(3,i,j,k) = vz"
  write(ilun,format)"                    xi = boxlen*((i-0.5)/n_size)-x0"
  write(ilun,format)"                    yi = boxlen*((j-0.5)/n_size)-y0"
  write(ilun,format)"                    zi = boxlen*((k-0.5)/n_size)-z0"
  write(ilun,format)"                    rs=sqrt(xi**2+yi**2+zi**2)"
  write(ilun,format)""
  write(ilun,format)"                    IF(rs .le. r0) THEN "
  write(ilun,format)"                       !                    print*, vx_tot,vy_tot,vz_tot,vx2_tot,vy2_tot,vz2_tot"
  write(ilun,format)"                       vx_tot = vx_tot + vx"
  write(ilun,format)"                       vy_tot = vy_tot + vy"
  write(ilun,format)"                       vz_tot = vz_tot + vz"
  write(ilun,format)""
  write(ilun,format)"                       vx2_tot = vx2_tot + vx**2"
  write(ilun,format)"                       vy2_tot = vy2_tot + vy**2"
  write(ilun,format)"                       vz2_tot = vz2_tot + vz**2"
  write(ilun,format)""
  write(ilun,format)"                       count_vrms=count_vrms+1"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           close(20)"
  write(ilun,format)"           v_rms=sqrt((vx2_tot+vy2_tot+vz2_tot)/dble(count_vrms)-((vx_tot+vy_tot+vz_tot)/dble(count_vrms))**2)"
  write(ilun,format)"           if (myid == 1) print *, 'v_rms for given seed =',v_rms"
  write(ilun,format)"           ! correction factor to have the expected Mach number stored in v_rms"
  write(ilun,format)"           v_rms = Mach*C_s/v_rms"
  write(ilun,format)"           if (myid == 1) print *, 'correction factor for turbulent field =',v_rms"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           print*,'alpha=',alpha"
  write(ilun,format)"           print*,'beta=',beta"
  write(ilun,format)"           print*,'Mass=',mass_c*scale_m/Msun,' Msun'"
  write(ilun,format)"           print*,'d0=',d0*scale_d"
  write(ilun,format)"           print*,'Turbulent Mach=',Mach"
  write(ilun,format)"           print*,r0,boxlen"
  write(ilun,format)"        endif"
  write(ilun,format)"        first = .false."
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! vertical magnetic field"
  write(ilun,format)"     B0 = sqrt(4.*pi/5.)/0.53*(crit*d0*r0) ! Remember G=1 in code units"
  write(ilun,format)""
  write(ilun,format)"     DO i=1,nn"
  write(ilun,format)"        xx=x(i,1)-x0"
  write(ilun,format)"        yy=x(i,2)-y0"
  write(ilun,format)"        zz=x(i,3)-z0"
  write(ilun,format)""
  write(ilun,format)"        q(i,iu) = 0.0d0"
  write(ilun,format)"        q(i,iv) = 0.0d0"
  write(ilun,format)"        q(i,iw) = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"        if(Mach .ne. 0)then"
  write(ilun,format)"           !initialise the turbulent velocity field"
  write(ilun,format)"           !make a zero order interpolation (should be improved)"
  write(ilun,format)"           ind_i = int((x(i,1)/boxlen)*n_size)+1"
  write(ilun,format)"           ind_j = int((x(i,2)/boxlen)*n_size)+1"
  write(ilun,format)"           ind_k = int((x(i,3)/boxlen)*n_size)+1"
  write(ilun,format)"           ! safe check"
  write(ilun,format)"           if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,(x(i,1)/boxlen)*n_size+1,n_size"
  write(ilun,format)"           if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j"
  write(ilun,format)"           if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        rc=sqrt(xx**2+yy**2)"
  write(ilun,format)"        rs=sqrt(xx**2+yy**2+zz**2)"
  write(ilun,format)""
  write(ilun,format)"        IF(rs .le. r0) THEN "
  write(ilun,format)""
  write(ilun,format)"           q(i,id) = d0*(1.0+delta_rho*cos(2.*atan(yy/(cos(theta_mag_radians)*xx-sin(theta_mag_radians)*zz))))"
  write(ilun,format)"           if(Mach .ne. 0)then"
  write(ilun,format)"              q(i,iu) =  v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot/dble(count_vrms))"
  write(ilun,format)"              q(i,iv) =  v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot/dble(count_vrms))"
  write(ilun,format)"              q(i,iw) =  v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot/dble(count_vrms))"
  write(ilun,format)"           end if"
  write(ilun,format)"           q(i,iu:iw) = q(i,iu:iw)+matmul(rot_invM,omega0*matmul(rot_tilde,matmul(rot_M,(/xx,yy,zz/))))"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)"              q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)"
  write(ilun,format)"           enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"        ELSE"
  write(ilun,format)"           q(i,id) = d0/contrast"
  write(ilun,format)"           xx = r0 * xx / rc"
  write(ilun,format)"           yy = r0 * yy / rc"
  write(ilun,format)"           if(Mach .ne. 0)then"
  write(ilun,format)"              q(i,iu) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot/dble(count_vrms))! omega0 * yy"
  write(ilun,format)"              q(i,iv) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot/dble(count_vrms))!-omega0 * xx"
  write(ilun,format)"              q(i,iw) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot/dble(count_vrms))"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"           do igroup=1,ngrp"
  write(ilun,format)"              q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)"
  write(ilun,format)"           enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"        ENDIF"
  write(ilun,format)""
  write(ilun,format)"        IF(rc .le. r0) THEN"
  write(ilun,format)"           !Bx component"
  write(ilun,format)"           q(i,6     ) = 0.0d0"
  write(ilun,format)"           q(i,nvar+1) = q(i,6)"
  write(ilun,format)""
  write(ilun,format)"           !By component"
  write(ilun,format)"           q(i,7     ) = 0.d0"
  write(ilun,format)"           q(i,nvar+2) = q(i,7)"
  write(ilun,format)""
  write(ilun,format)"           !Bz component"
  write(ilun,format)"           q(i,8     ) = B0"
  write(ilun,format)"           q(i,nvar+3) = q(i,8)"
  write(ilun,format)"        ELSE"
  write(ilun,format)"           !Bx component"
  write(ilun,format)"           q(i,6     ) = 0.0d0"
  write(ilun,format)"           q(i,nvar+1) = q(i,6)"
  write(ilun,format)""
  write(ilun,format)"           !By component"
  write(ilun,format)"           q(i,7     ) = 0.d0"
  write(ilun,format)"           q(i,nvar+2) = q(i,7)"
  write(ilun,format)""
  write(ilun,format)"           !Bz component"
  write(ilun,format)"           q(i,8     ) = B0 /(contrast**(2./3.))"
  write(ilun,format)"           q(i,nvar+3) = q(i,8)"
  write(ilun,format)"        END IF"
  write(ilun,format)""
  write(ilun,format)"        if(eos)then"
  write(ilun,format)"           call enerint_eos(q(i,1),Temp,ee)"
  write(ilun,format)"           q(i,5   ) = ee"
  write(ilun,format)"           q(i,nvar) = ee"
  write(ilun,format)"        else"
  write(ilun,format)"           q(i,5) = q(i,1) * C_s**2/(gamma-1.0d0)"
  write(ilun,format)"           q(i,nvar) = q(i,5)"
  write(ilun,format)"        endif"
  write(ilun,format)"     ENDDO"
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)""
  write(ilun,format)"     !do various things which needs to be done only one time"
  write(ilun,format)"     if( first ) then "
  write(ilun,format)"        id=1; iu=2; iv=3; iw=4; ip=5"
  write(ilun,format)"        pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1) write(*,*) '** ENTER  in condinit **'"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !calculate the mass in code units (Msolar / Mparticle / pc^3"
  write(ilun,format)"        !    mass_c = mass_c * (Msun / (scale_d * scale_l**3) )"
  write(ilun,format)"        !    done in calc_boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(myid ==1) write(*,*) 'cloud mass (code units) ',mass_c"
  write(ilun,format)""
  write(ilun,format)"        !calculate the sound speed"
  write(ilun,format)"        C_s = sqrt( Tr_floor / scale_T2 )"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        if(myid == 1)  write(*,*) 'T_0 (K) ', Tr_floor"
  write(ilun,format)"        if(myid == 1)  write(*,*)  'C_s (code units) ', C_s"
  write(ilun,format)""
  write(ilun,format)"        !cont_ic is the density contrast between the edge of the cloud and the intercloud medium"
  write(ilun,format)"        cont_ic = 10."
  write(ilun,format)""
  write(ilun,format)"        !calculate  zeta=r_ext/r_0"
  write(ilun,format)"        zeta = sqrt(cont - 1.)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !calculate an integral used to compute the cloud radius "
  write(ilun,format)"        res_int=0."
  write(ilun,format)"        do i=1,1000"
  write(ilun,format)"           res_int = res_int + log(1.+(zeta/1000.*i)**2) * zeta/1000."
  write(ilun,format)"           mass_rad(i) = i*zeta/1000. * log(1+(zeta/1000.*i)**2) - res_int"
  write(ilun,format)"        enddo"
  write(ilun,format)"        res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !now we determine the central density and the external cloud radius"
  write(ilun,format)"        !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"        !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"        !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"        !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0 ) "
  write(ilun,format)"        !which just state the ratio of freefall time over sound crossing time "
  write(ilun,format)"        !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)""
  write(ilun,format)"        !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"        r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)""
  write(ilun,format)"        if (myid ==1) write(*,*) 'inner radius (pc) ',r_0"
  write(ilun,format)""
  write(ilun,format)"        d_c = mass_c / (2.*pi*rap*res_int) / r_0**3"
  write(ilun,format)""
  write(ilun,format)"        if(myid ==1) write(*,*) 'central density ',d_c"
  write(ilun,format)""
  write(ilun,format)"        ener_therm = 3./2.*mass_c*C_s**2"
  write(ilun,format)"        ener_grav  = 3./5.*(mass_c**2)/(r_0*zeta)"
  write(ilun,format)"        ener_grav2=0."
  write(ilun,format)"        do i=1,1000"
  write(ilun,format)"           ener_grav2 = ener_grav2 + (i*zeta/1000.) / (1.+(zeta/1000.*i)**2) * zeta/1000. * mass_rad(i)"
  write(ilun,format)"        enddo"
  write(ilun,format)"        ener_grav2 = ener_grav2 * 8.*(pi**2)*(d_c**2)*(r_0**5)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !angular velocity"
  write(ilun,format)"        omega = ff_rt * 2.*pi * sqrt( 32.*d_c/3./pi)    "
  write(ilun,format)"        if (myid==1) write(*,*)'Angular velocity Omega = ',omega/(2.0*pi)/scale_t, 'Hz'"
  write(ilun,format)"        !central value of magnetic field"
  write(ilun,format)"        !remember magnetic variable is B/sqrt(4pi)"
  write(ilun,format)"        if(.not.uniform_bmag)then"
  write(ilun,format)"           !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"           B_c = ff_act * sqrt( 32./3./pi) * d_c * r_0 "
  write(ilun,format)""
  write(ilun,format)"           mass_sph = d_c / cont * (boxlen*(0.5**levelmin))**3"
  write(ilun,format)""
  write(ilun,format)"           !the smallest initial column density"
  write(ilun,format)"           min_col_d = boxlen * d_c / cont / cont_ic "
  write(ilun,format)""
  write(ilun,format)"           !the largest initial column density"
  write(ilun,format)"           !obtained by integrating the density distribution through the box"
  write(ilun,format)"           max_col_d = r_0*d_c*atan(zeta) + (boxlen -2.*r_0*zeta) * d_c / cont / cont_ic "
  write(ilun,format)""
  write(ilun,format)"           if (myid==1) write(*,*) 'valeur du champ magnetique central non normalise B_c', B_c"
  write(ilun,format)"           if (myid==1) write(*,*) 'valeur du champ magnetique a l exterieur ', B_c*min_col_d/max_col_d"
  write(ilun,format)""
  write(ilun,format)"           !calculate the value of mu the mass to flux over critical mass to flux ratio"
  write(ilun,format)"           !from Mouschovias & Spitzer 1979 M/phi)_crit = 1/(3pi) * sqrt(5/G) * 0.53"
  write(ilun,format)"           !since B(r)=B_c * sig(r)/sig(0), phi = B_c * mass_c / sig(0)"
  write(ilun,format)"           !thus mass_c / phi = sig(0) / B_c "
  write(ilun,format)"           !taking into account the fact that B_c = champ mag / sqrt(4 pi)"
  write(ilun,format)"           ! we have in code units mu = sig(0) / (B_c*sqrt(4 pi)) / (sqrt(5)/(3 pi) * 0.53)"
  write(ilun,format)"           if (myid ==1) write(*,*) 'the mass to flux over critical mass to flux ratio in the case of a spheroidal cloud (not correct if rap ne 1)'"
  write(ilun,format)"           if (myid ==1) then"
  write(ilun,format)"              if (B_c.lt.1.e-10) then"
  write(ilun,format)"                 write(*,*) 'mu= +Infinity'"
  write(ilun,format)"              else"
  write(ilun,format)"                 write(*,*) 'mu= ',max_col_d / (B_c*sqrt(4.*pi)) / (sqrt(5.)/(3.*pi) * 0.53)"
  write(ilun,format)"              endif"
  write(ilun,format)"           end if"
  write(ilun,format)"           !note here we make the approximation that max_col_d is equal to the column density through the cloud which is note exactly "
  write(ilun,format)"           !the case since the column density of the external medium is also taken into account"
  write(ilun,format)"        else"
  write(ilun,format)"           !bc switch to uniform magnetic field if keyword uniform_bmag "
  write(ilun,format)"           !calculate the value of mu the mass to flux over critical mass to flux ratio at the core boundary"
  write(ilun,format)"           !from Mouschovias & Spitzer 1979 M/phi)_crit = 1/(3pi) * sqrt(5/G) * 0.53"
  write(ilun,format)""
  write(ilun,format)"           B_c =mass_c*crit/(pi*(r_0*zeta)**2)/ (sqrt(5.)/(3.*pi) * 0.53)/sqrt(4.*pi)"
  write(ilun,format)""
  write(ilun,format)"           mass_sph = d_c / cont * (boxlen*(0.5**levelmin))**3"
  write(ilun,format)""
  write(ilun,format)"           !the smallest initial column density"
  write(ilun,format)"           min_col_d = boxlen * d_c / cont / cont_ic "
  write(ilun,format)""
  write(ilun,format)"           !the largest initial column density"
  write(ilun,format)"           !obtained by integrating the density distribution through the box"
  write(ilun,format)"           max_col_d = r_0*d_c*atan(zeta) + (boxlen -2.*r_0*zeta) * d_c / cont / cont_ic "
  write(ilun,format)""
  write(ilun,format)"           if (myid ==1) write(*,*) 'the mass to flux over critical mass to flux ratio in the case of a spheroidal cloud (not correct if rap ne 1)'"
  write(ilun,format)"           if (myid ==1) then"
  write(ilun,format)"              if (B_c.lt.1.e-10) then"
  write(ilun,format)"                 write(*,*) 'mu= +Infinity'"
  write(ilun,format)"              else"
  write(ilun,format)"                 write(*,*) 'mu= ',1.0/crit"
  write(ilun,format)"              endif"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)"        !now read the turbulent velocity field used as initial condition"
  write(ilun,format)"        v_rms=0."
  write(ilun,format)"        mass_total=0."
  write(ilun,format)"        mass_tot2 =0."
  write(ilun,format)"        ener_turb=0."
  write(ilun,format)"        ener_rot=0."
  write(ilun,format)"        n_size=0"
  write(ilun,format)"        vx_tot=0.d0"
  write(ilun,format)"        vy_tot=0.d0"
  write(ilun,format)"        vz_tot=0.d0"
  write(ilun,format)"        vx2_tot=0.d0"
  write(ilun,format)"        vy2_tot=0.d0"
  write(ilun,format)"        vz2_tot=0.d0"
  write(ilun,format)""
  write(ilun,format)"        if(ff_vct .ne. 0)then"
  write(ilun,format)"           if( myid ==1) write(*,*) 'Read the file which contains the initial turbulent velocity field'"
  write(ilun,format)"           open(20,file='init_turb.data',form='formatted')"
  write(ilun,format)"           read(20,*) n_size, ind, seed1,seed2,seed3"
  write(ilun,format)""
  write(ilun,format)"           if(n_size .ne. 100) then "
  write(ilun,format)"              write(*,*) 'Unexpected field size'"
  write(ilun,format)"              stop"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           do k=1,n_size"
  write(ilun,format)"              do j=1,n_size"
  write(ilun,format)"                 do i=1,n_size"
  write(ilun,format)"                    read(20,*)xi,yi,zi,vx,vy,vz"
  write(ilun,format)"                    q_idl(1,i,j,k) = vx"
  write(ilun,format)"                    q_idl(2,i,j,k) = vy"
  write(ilun,format)"                    q_idl(3,i,j,k) = vz"
  write(ilun,format)""
  write(ilun,format)"                    xi = boxlen*((i-0.5)/n_size-0.5)"
  write(ilun,format)"                    yi = boxlen*((j-0.5)/n_size-0.5)"
  write(ilun,format)"                    zi = boxlen*((k-0.5)/n_size-0.5)"
  write(ilun,format)"                    eli =  (xi/r_0)**2+(yi/r_0)**2+(zi/(r_0*rap))**2"
  write(ilun,format)""
  write(ilun,format)"                    if( eli .lt. zeta**2) then"
  write(ilun,format)""
  write(ilun,format)"                       vx_tot = vx_tot + d_c/(1.+eli)*vx"
  write(ilun,format)"                       vy_tot = vy_tot + d_c/(1.+eli)*vy"
  write(ilun,format)"                       vz_tot = vz_tot + d_c/(1.+eli)*vz"
  write(ilun,format)""
  write(ilun,format)"                       vx2_tot = vx2_tot + d_c/(1.+eli)*vx**2"
  write(ilun,format)"                       vy2_tot = vy2_tot + d_c/(1.+eli)*vy**2"
  write(ilun,format)"                       vz2_tot = vz2_tot + d_c/(1.+eli)*vz**2"
  write(ilun,format)""
  write(ilun,format)"                       ener_turb = ener_turb + d_c/(1.+eli)*(vx**2+vy**2+vz**2)"
  write(ilun,format)"                       mass_total = mass_total +  d_c / (1.+eli)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 !       eli = (yi/r_0)**2 + (zi/r_0/rap)**2"
  write(ilun,format)"                 !        if( eli .lt. zeta**2) then"
  write(ilun,format)"                 !          col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )"
  write(ilun,format)"                 !          mass_tot2 = mass_tot2 + col_d"
  write(ilun,format)"                 !        endif "
  write(ilun,format)"              enddo"
  write(ilun,format)"           enddo"
  write(ilun,format)"           close(20)"
  write(ilun,format)""
  write(ilun,format)"           vx_tot = vx_tot / mass_total"
  write(ilun,format)"           vy_tot = vy_tot / mass_total"
  write(ilun,format)"           vz_tot = vz_tot / mass_total"
  write(ilun,format)""
  write(ilun,format)"           vx2_tot = vx2_tot / mass_total"
  write(ilun,format)"           vy2_tot = vy2_tot / mass_total"
  write(ilun,format)"           vz2_tot = vz2_tot / mass_total"
  write(ilun,format)""
  write(ilun,format)"           v_rms = sqrt( vx2_tot-vx_tot**2 + vy2_tot-vy_tot**2 + vz2_tot-vz_tot**2 ) "
  write(ilun,format)""
  write(ilun,format)"           mass_total = mass_total*(boxlen/n_size)**3"
  write(ilun,format)"           if (myid ==1) write(*,*) 'We verify the calculation for the mass. The 2 following values must be very close:'"
  write(ilun,format)"           if (myid ==1) write(*,*) 'mass_total, mass_c ',mass_total, mass_c !,mass_tot2"
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        n_size=100"
  write(ilun,format)"        do k=1,n_size"
  write(ilun,format)"           do j=1,n_size"
  write(ilun,format)"              do i=1,n_size"
  write(ilun,format)""
  write(ilun,format)"                 xi = boxlen*((i-0.5)/n_size-0.5)"
  write(ilun,format)"                 yi = boxlen*((j-0.5)/n_size-0.5)"
  write(ilun,format)"                 zi = boxlen*((k-0.5)/n_size-0.5)"
  write(ilun,format)"                 eli =  (xi/r_0)**2+(yi/r_0)**2+(zi/(r_0*rap))**2"
  write(ilun,format)""
  write(ilun,format)"                 if( eli .lt. zeta**2) then"
  write(ilun,format)"                    ener_rot = ener_rot + d_c/(1.+eli) * omega**2 * (yi**2 + zi**2)"
  write(ilun,format)"                 endif"
  write(ilun,format)"              enddo"
  write(ilun,format)"           enddo"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        ener_rot  = 0.5 * ener_rot*(boxlen/n_size)**3"
  write(ilun,format)"        ener_turb = 0.5 * ener_turb*(boxlen/n_size)**3"
  write(ilun,format)""
  write(ilun,format)"        !estimate of the thermal over gravitational energy "
  write(ilun,format)"        if (myid == 1) write(*,*) 'estimate (uniform density is assumed) of the ratio of thermal over gravitational energy'"
  write(ilun,format)"        if (myid == 1) write(*,*)  ener_therm / ener_grav"
  write(ilun,format)""
  write(ilun,format)"        if (myid == 1) write(*,*) 'good estimate of the ratio of thermal over gravitational energy'"
  write(ilun,format)"        if (myid == 1) write(*,*)  ener_therm / ener_grav2"
  write(ilun,format)""
  write(ilun,format)"        if (myid .eq. 1) write(*,*) 'estimate of the rotational over gravitational energy ratio'"
  write(ilun,format)"        if (myid .eq. 1) write(*,*) 'ener_rot/ener_grav2 ', ener_rot / ener_grav2, ener_rot , ener_grav2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !calculate now the coefficient by which the turbulence velocity needs"
  write(ilun,format)"        !to be multiplied "
  write(ilun,format)"        if(v_rms .ne.0)then"
  write(ilun,format)"           if (myid .eq. 1) write(*,*) 'vrms non norm ',v_rms"
  write(ilun,format)""
  write(ilun,format)"           !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"           v_rms = ff_vct * sqrt(32.*d_c/3./pi)*r_0 / v_rms"
  write(ilun,format)""
  write(ilun,format)"           if (myid .eq. 1) write(*,*) 'vrms mult ',v_rms"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           !estimate of the turbulent over gravitational energy ratio"
  write(ilun,format)"           if (myid .eq. 1) write(*,*) 'estimate of the turbulent over gravitational energy ratio'"
  write(ilun,format)"           if (myid .eq. 1) write(*,*) 'ener_turb/ener_grav2 ', ener_turb*(v_rms**2) / ener_grav2"
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"100     format(i5,4e12.5)"
  write(ilun,format)"101     format(6e12.5)"
  write(ilun,format)"102     format(i5)"
  write(ilun,format)""
  write(ilun,format)"        if (myid ==1)  write(*,*) 'Reading achieved'"
  write(ilun,format)"        first = .false."
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     Temp = tr_floor"
  write(ilun,format)""
  write(ilun,format)"     DO i=1,nn"
  write(ilun,format)""
  write(ilun,format)"        x(i,1) = x(i,1) - 0.5*boxlen"
  write(ilun,format)"        x(i,2) = x(i,2) - 0.5*boxlen"
  write(ilun,format)"        x(i,3) = x(i,3) - 0.5*boxlen"
  write(ilun,format)""
  write(ilun,format)"        q(i,2) = 0.0d0"
  write(ilun,format)"        q(i,3) = 0.0d0"
  write(ilun,format)"        q(i,4) = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"        !initialise the density field"
  write(ilun,format)"        eli =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0*rap))**2"
  write(ilun,format)""
  write(ilun,format)"        if( eli .gt. zeta**2) then "
  write(ilun,format)"           q(i,1) = d_c / cont / cont_ic"
  write(ilun,format)""
  write(ilun,format)"           if(eos)then"
  write(ilun,format)"              call enerint_eos(q(i,1),Temp,ee)"
  write(ilun,format)"              q(i,5) = ee"
  write(ilun,format)"              !if the cloud is in pressure equilibrium with the surrounding medium"
  write(ilun,format)"              !remove this line if the IC gas is isothermal as well "
  write(ilun,format)"              !        q(i,5) = q(i,5) * cont_ic "
  write(ilun,format)"              q(i,nvar) = ee"
  write(ilun,format)"           else"
  write(ilun,format)"              q(i,5) = q(i,1) * C_s**2/(gamma-1.0d0)"
  write(ilun,format)"              q(i,nvar) = q(i,5)"
  write(ilun,format)"           endif"
  write(ilun,format)"        else"
  write(ilun,format)"           q(i,1) = d_c / (1.+eli)"
  write(ilun,format)""
  write(ilun,format)"           if(eos)then"
  write(ilun,format)"              call enerint_eos(q(i,1),Temp,ee)"
  write(ilun,format)"              q(i,5   ) = ee"
  write(ilun,format)"              q(i,nvar) = ee"
  write(ilun,format)"           else"
  write(ilun,format)"              q(i,5) = q(i,1) * C_s**2/(gamma-1.0d0)"
  write(ilun,format)"              q(i,nvar) = q(i,5)"
  write(ilun,format)"           endif"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"        do igroup=1,ngrp"
  write(ilun,format)"           q(i,firstindex_er+igroup) = radiation_source(Temp,igroup)/(scale_d*scale_v**2)"
  write(ilun,format)"        enddo"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        if(v_rms .ne. 0)then"
  write(ilun,format)"           !initialise the turbulent velocity field"
  write(ilun,format)"           !make a zero order interpolation (should be improved)"
  write(ilun,format)"           ind_i = int((x(i,1)/boxlen+0.5)*n_size)+1"
  write(ilun,format)"           ind_j = int((x(i,2)/boxlen+0.5)*n_size)+1"
  write(ilun,format)"           ind_k = int((x(i,3)/boxlen+0.5)*n_size)+1"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           if( ind_i .lt. 1 .or. ind_i .gt. n_size) write(*,*) 'ind_i ',ind_i,boxlen,x(i,1),n_size"
  write(ilun,format)"           if( ind_j .lt. 1 .or. ind_j .gt. n_size) write(*,*) 'ind_j ',ind_j"
  write(ilun,format)"           if( ind_k .lt. 1 .or. ind_k .gt. n_size) write(*,*) 'ind_k ',ind_k"
  write(ilun,format)""
  write(ilun,format)"           q(i,2) = v_rms*(q_idl(1,ind_i,ind_j,ind_k)-vx_tot)"
  write(ilun,format)"           q(i,3) = v_rms*(q_idl(2,ind_i,ind_j,ind_k)-vy_tot)"
  write(ilun,format)"           q(i,4) = v_rms*(q_idl(3,ind_i,ind_j,ind_k)-vz_tot)"
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        !add  rotation. x cos(theta_mag_radians) + y sin(theta_mag_radians) is the rotation axis"
  write(ilun,format)"        sph =  (x(i,1)/r_0)**2+(x(i,2)/r_0)**2+(x(i,3)/(r_0))**2"
  write(ilun,format)"        if( sph .lt. (zeta*rap)**2 ) then "
  write(ilun,format)""
  write(ilun,format)"           !to check these formulae one can verify that those arrays are perpendicular"
  write(ilun,format)"           !with (cos(theta_mag_radians),sin(theta_mag_radians),0) and that the norm of the vectorial product of"
  write(ilun,format)"           ! (cos(theta_mag_radians),sin(theta_mag_radians),0) by the above arrays is equal to the distance"
  write(ilun,format)"           !  (x sin(thet)-y cos(thet))^2 + z^2 "
  write(ilun,format)"           q(i,2) = q(i,2) - (omega*x(i,3)*sin(theta_mag_radians))"
  write(ilun,format)"           q(i,3) = q(i,3) + (omega*x(i,3)*cos(theta_mag_radians))"
  write(ilun,format)"           q(i,4) = q(i,4) + (omega*(x(i,1)*sin(theta_mag_radians)-x(i,2)*cos(theta_mag_radians)))"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ENDDO"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     dxmin=boxlen*0.5d0**(levelmin+3)"
  write(ilun,format)""
  write(ilun,format)"     if( dx .lt. dxmin) then "
  write(ilun,format)"        write(*,*) 'dxmin too large'"
  write(ilun,format)"        write(*,*) 'dx ',dx/boxlen"
  write(ilun,format)"        write(*,*) 'dxmin ',dxmin/boxlen"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     nticks=dx/dxmin"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     DO i=1,nn"
  write(ilun,format)"        q(i,6)=0."
  write(ilun,format)""
  write(ilun,format)"        xl=x(i,1)-0.5*dx"
  write(ilun,format)"        yl=x(i,2)-0.5*dx"
  write(ilun,format)"        zl=x(i,3)-0.5*dx"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        !the magnetic field in cells must be subdivided in order to insure that the magnetic"
  write(ilun,format)"        !flux is the same in coarse and refined grids"
  write(ilun,format)"        DO jj=1,nticks"
  write(ilun,format)"           DO kk=1,nticks"
  write(ilun,format)""
  write(ilun,format)"              yy=yl+(dble(jj)-0.5d0)*dxmin"
  write(ilun,format)"              zz=zl+(dble(kk)-0.5d0)*dxmin"
  write(ilun,format)""
  write(ilun,format)"              !this formula comes from the integration of the density distribution along x"
  write(ilun,format)"              eli = (yy/r_0)**2 + (zz/r_0/rap)**2"
  write(ilun,format)"              if( eli .lt. zeta**2) then"
  write(ilun,format)"                 col_d = r_0*d_c/sqrt(1.+eli)*atan( sqrt( (zeta**2-eli)/(1.+eli) ) )"
  write(ilun,format)"                 col_d = max(col_d,min_col_d)"
  write(ilun,format)"              else "
  write(ilun,format)"                 col_d = min_col_d"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              !Bx component"
  write(ilun,format)"              if(uniform_bmag)then"
  write(ilun,format)"                 q(i,6     ) = q(i,6) + B_c"
  write(ilun,format)"              else"
  write(ilun,format)"                 q(i,6     ) = q(i,6) + B_c * col_d / max_col_d"
  write(ilun,format)"              end if"
  write(ilun,format)"              q(i,nvar+1) = q(i,6)"
  write(ilun,format)""
  write(ilun,format)"              !By component"
  write(ilun,format)"              q(i,7     ) = 0."
  write(ilun,format)"              q(i,nvar+2) = 0."
  write(ilun,format)""
  write(ilun,format)"              !Bz component"
  write(ilun,format)"              q(i,8     ) = 0."
  write(ilun,format)"              q(i,nvar+3) = 0."
  write(ilun,format)""
  write(ilun,format)"           ENDDO"
  write(ilun,format)"        ENDDO"
  write(ilun,format)""
  write(ilun,format)"        q(i,6:8)           = q(i,6:8)           / dble(nticks)**2"
  write(ilun,format)""
  write(ilun,format)"        !new version rotates the rotation velocity "
  write(ilun,format)"        !rotates the magnetic field of an angle theta"
  write(ilun,format)"        !       bx=q(i,6)"
  write(ilun,format)"        !       by=q(i,7)"
  write(ilun,format)"        !       q(i,6) =  bx*cos(theta_mag_radians) + by*sin(theta_mag_radians)"
  write(ilun,format)"        !       q(i,7) =  bx*sin(theta_mag_radians) - by*cos(theta_mag_radians)"
  write(ilun,format)""
  write(ilun,format)"        q(i,nvar+1:nvar+3) = q(i,6:8)"
  write(ilun,format)"     ENDDO"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Convert primitive to conservative variables"
  write(ilun,format)"  ! density -> density"
  write(ilun,format)"  u(1:nn,1)=q(1:nn,1)"
  write(ilun,format)"  ! velocity -> momentum"
  write(ilun,format)"  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)"
  write(ilun,format)"  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)"
  write(ilun,format)"  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)"
  write(ilun,format)"  ! kinetic energy"
  write(ilun,format)"  u(1:nn,5)=0.0d0"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,2)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,3)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,4)**2"
  write(ilun,format)"  ! pressure -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+q(1:nn,5)"
  write(ilun,format)"  ! magnetic energy -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,6)+q(1:nn,nvar+1))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,7)+q(1:nn,nvar+2))**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,8)+q(1:nn,nvar+3))**2"
  write(ilun,format)"  u(1:nn,6:8)=q(1:nn,6:8)"
  write(ilun,format)"  u(1:nn,nvar+1:nvar+3)=q(1:nn,nvar+1:nvar+3)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  ! non-thermal pressure -> non-thermal energy"
  write(ilun,format)"  ! non-thermal energy   -> total fluid energy"
  write(ilun,format)"  do ivar=1,nener-ngrp"
  write(ilun,format)"     u(1:nn,8+ivar)=q(1:nn,8+ivar)/(gamma_rad(ivar)-1.0d0)"
  write(ilun,format)"     u(1:nn,5)=u(1:nn,5)+u(1:nn,8+ivar)"
  write(ilun,format)"  enddo"
  write(ilun,format)" ! Radiative transfer"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"  ! radiative energy   -> total fluid energy"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     u(1:nn,firstindex_er+ivar)= q(1:nn,firstindex_er+ivar)"
  write(ilun,format)"     u(1:nn,5)=u(1:nn,5)+ u(1:nn,firstindex_er+ivar)"
  write(ilun,format)"  enddo"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  ! radiative flux"
  write(ilun,format)"  do ivar=1,ndim*ngrp"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        u(1:nn,fisrtindex_fr+ivar)=q(1:nn,firstindex+ivar)"
  write(ilun,format)"     end do"
  write(ilun,format)"     write(ilun)xdp"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NEXTINCT>0"
  write(ilun,format)"  ! Extinction"
  write(ilun,format)"  if(extinction)u(1:nn,firstindex_extinct+nextinct)=0.0D0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NPSCAL>0"
  write(ilun,format)"  ! passive scalars"
  write(ilun,format)"  do ivar=1,npscal"
  write(ilun,format)"     u(1:nn,firstindex_pscal+ivar)=q(1:nn,1)*q(1:nn,firstindex_pscal+ivar)"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! Internal energy"
  write(ilun,format)"  u(1:nn,nvar)=q(1:nn,5)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine condinit"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine velana(x,v,dx,t,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters  "
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Size of input arrays"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp)::t                             ! Current time"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3)::v    ! Velocity field"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine computes the user defined velocity fields."
  write(ilun,format)"  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units)."
  write(ilun,format)"  ! v(i,1:3) is the imposed 3-velocity in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::xx,yy,zz,vx,vy,vz,rr,tt,omega,aa,twopi"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"!!   aa=1.0"
  write(ilun,format)"!!   twopi=2d0*ACOS(-1d0)"
  write(ilun,format)"!!   do i=1,ncell"
  write(ilun,format)"!! "
  write(ilun,format)"!!      xx=x(i,1)"
  write(ilun,format)"!! #if NDIM > 1"
  write(ilun,format)"!!      yy=x(i,2)"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!! #if NDIM > 2"
  write(ilun,format)"!!      zz=x(i,3)"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!      ! ABC"
  write(ilun,format)"!!      vx=aa*(cos(twopi*yy)+sin(twopi*zz))"
  write(ilun,format)"!!      vy=aa*(sin(twopi*xx)+cos(twopi*zz))"
  write(ilun,format)"!!      vz=aa*(cos(twopi*xx)+sin(twopi*yy))"
  write(ilun,format)"!! "
  write(ilun,format)"!!      ! 1D advection test"
  write(ilun,format)"!!      vx=1.0_dp"
  write(ilun,format)"!!      vy=0.0_dp"
  write(ilun,format)"!!      vz=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"!!      ! Ponomarenko"
  write(ilun,format)"!!      xx=xx-boxlen/2.0"
  write(ilun,format)"!!      yy=yy-boxlen/2.0"
  write(ilun,format)"!!      rr=sqrt(xx**2+yy**2)"
  write(ilun,format)"!!      if(yy>0)then"
  write(ilun,format)"!!         tt=acos(xx/rr)"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         tt=-acos(xx/rr)+twopi"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      if(rr<1.0)then"
  write(ilun,format)"!!         omega=0.609711"
  write(ilun,format)"!!         vz=0.792624"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         omega=0.0"
  write(ilun,format)"!!         vz=0.0"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      vx=-sin(tt)*rr*omega"
  write(ilun,format)"!!      vy=+cos(tt)*rr*omega"
  write(ilun,format)"     "
  write(ilun,format)"!!      v(i,1)=vx"
  write(ilun,format)"!! #if NDIM > 1"
  write(ilun,format)"!!      v(i,2)=vy"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!! #if NDIM > 2"
  write(ilun,format)"!!      v(i,3)=vz"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!   end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine velana"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"subroutine calc_boxlen"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH"
  write(ilun,format)"  use units_commons"
  write(ilun,format)" "
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  !this routine calculate boxlen"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer :: i"
  write(ilun,format)"  real(dp):: pi"
  write(ilun,format)"  real(dp):: d_c,zeta"
  write(ilun,format)"  real(dp):: res_int,r_0,C_s"
  write(ilun,format)"  integer::  np"
  write(ilun,format)"  logical,save:: first=.true."
  write(ilun,format)""
  write(ilun,format)"    if (first) then"
  write(ilun,format)""
  write(ilun,format)"    pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"    !calculate the mass in code units (Msolar / Mparticle / pc^3"
  write(ilun,format)"    mass_c = mass_c * (Msun / scale_m )"
  write(ilun,format)""
  write(ilun,format)"    !calculate the sound speed"
  write(ilun,format)"    C_s = sqrt( Tr_floor / scale_T2 )"
  write(ilun,format)""
  write(ilun,format)"    "
  write(ilun,format)"    if(bb_test)then"
  write(ilun,format)"       r_0 = (alpha*2.*6.67d-8*mass_c*mu_gas*mH/(5.*kB*Tr_floor))/scale_l* scale_m "
  write(ilun,format)"       boxlen = r_0 * 4."
  write(ilun,format)"       "
  write(ilun,format)"       if (myid == 1) then "
  write(ilun,format)"          write(*,*) '** Cloud parameters estimated in calc-boxlen **' "
  write(ilun,format)"          write(*,*) 'inner radius (pc) ', r_0"
  write(ilun,format)"          write(*,*) 'total box length (pc) ', boxlen"
  write(ilun,format)"          write(*,*) 'cloud mass (code units) ', mass_c"
  write(ilun,format)"          write(*,*) "
  write(ilun,format)"       endif"
  write(ilun,format)"   "
  write(ilun,format)"    else"
  write(ilun,format)"       !calculate  zeta=r_ext/r_0"
  write(ilun,format)"       zeta = sqrt(cont - 1.)"
  write(ilun,format)"       "
  write(ilun,format)"       !calculate an integral used to compute the cloud radius "
  write(ilun,format)"       np=1000"
  write(ilun,format)"       res_int=0."
  write(ilun,format)"       do i=1,np"
  write(ilun,format)"          res_int = res_int + log(1.+(zeta/np*i)**2) * zeta/np"
  write(ilun,format)"       enddo"
  write(ilun,format)"       res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)"       "
  write(ilun,format)"       !now we determine the central density and the external cloud radius"
  write(ilun,format)"       !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"       !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"       !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"       !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0) "
  write(ilun,format)"       !which just state the ratio of freefall time over sound crossing time "
  write(ilun,format)"       !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)"       "
  write(ilun,format)"       "
  write(ilun,format)"       "
  write(ilun,format)"       r_0 = mass_c / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)""
  write(ilun,format)"       d_c = mass_c / (2.*pi*rap*res_int) / r_0**3"
  write(ilun,format)"       "
  write(ilun,format)"       !it is equal to twice the length of the major axis"
  write(ilun,format)"       boxlen = r_0 * zeta * max(rap,1.) * 4."
  write(ilun,format)"       "
  write(ilun,format)"       if (myid == 1) then "
  write(ilun,format)"          write(*,*) '** Cloud parameters estimated in calc-boxlen **' "
  write(ilun,format)"          write(*,*) 'inner radius (pc) ', r_0 "
  write(ilun,format)"          write(*,*) 'peak density (cc) ', d_c"
  write(ilun,format)"          write(*,*) 'total box length (pc) ', boxlen"
  write(ilun,format)"          write(*,*) 'cloud mass (code units) ', mass_c"
  write(ilun,format)"          write(*,*) "
  write(ilun,format)"       endif"
  write(ilun,format)"       "
  write(ilun,format)"    endif"
  write(ilun,format)"       "
  write(ilun,format)"    first=.false."
  write(ilun,format)" endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine calc_boxlen  "
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"!========================================================================================"
  write(ilun,format)"function compute_db()"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH"
  write(ilun,format)"  use units_commons"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::res_int,d0,r0,pi,c_s,zeta,compute_db,mass_c2"
  write(ilun,format)"  "
  write(ilun,format)"  C_s = sqrt( Tr_floor / scale_T2 )"
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  !calculate  zeta=r_ext/r_0"
  write(ilun,format)"  zeta = sqrt(cont - 1.)"
  write(ilun,format)"  mass_c2 = mass_c * (Msun / scale_m )     "
  write(ilun,format)""
  write(ilun,format)"  if(bb_test)then"
  write(ilun,format)"     "
  write(ilun,format)"     pi=2.0d0*asin(1.0d0)"
  write(ilun,format)"     r0=(alpha*2.*6.67d-8*mass_c2*scale_m*mu_gas*mH/(5.*kB*Tr_floor))/scale_l"
  write(ilun,format)"     d0 = 3.0d0*mass_c2/(4.0d0*pi*r0**3.)"
  write(ilun,format)"     compute_db=d0/contrast"
  write(ilun,format)"     "
  write(ilun,format)"  else"
  write(ilun,format)"     !calculate an integral used to compute the cloud radius "
  write(ilun,format)"     res_int=0."
  write(ilun,format)"     do i=1,1000"
  write(ilun,format)"        res_int = res_int + log(1.+(zeta/1000.*i)**2) * zeta/1000."
  write(ilun,format)"      enddo"
  write(ilun,format)"     res_int = zeta*log(1.+zeta**2) - res_int"
  write(ilun,format)"     "
  write(ilun,format)""
  write(ilun,format)"     !now we determine the central density and the external cloud radius"
  write(ilun,format)"     !we have mass = 2 pi rho_c r_0^2 z_0 * res_int"
  write(ilun,format)"     !which results from the integration of rho = dc/(1.+(x^2+y^2)/r_O^2+z^2/z_0^2)"
  write(ilun,format)"     !for (x^2+y^2)/r_O^2+z^2/z_0^2 < zeta"
  write(ilun,format)"     !we also have ff_sct = sqrt(3. pi / 32 / G / d_c) C_s / (r_0 ) "
  write(ilun,format)"     !which just state the ratio of freefall time over sound crossing time "
  write(ilun,format)"     !from these 2 formula, rho_c and r_0 are found to be:"
  write(ilun,format)"     "
  write(ilun,format)"     !ph 01/09 new definition entails r_0 instead of r_0 * zeta, the external radius"
  write(ilun,format)"     r0 = mass_c2 / (2.*pi*rap*res_int) * (ff_sct)**2 / (3.*pi/32.) / C_s**2"
  write(ilun,format)"               "
  write(ilun,format)"     d0 = mass_c2 / (2.*pi*rap*res_int) / r0**3"
  write(ilun,format)""
  write(ilun,format)"     compute_db=d0 / cont / 10."
  write(ilun,format)"     "
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  return"
  write(ilun,format)"  "
  write(ilun,format)"end function compute_db"
  write(ilun,format)"../patch/collapse/cooling_fine.f90"
  write(ilun,format)"subroutine cooling_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  ! Compute cooling for fine levels"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  integer::ncache,i,igrid,ngrid,info"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid"
  write(ilun,format)"#ifdef grackle"
  write(ilun,format)"  integer:: iresult, initialize_grackle"
  write(ilun,format)"  real(kind=8)::density_units,length_units,time_units,velocity_units,temperature_units,a_units=1.0,a_value=1.0"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! files"
  write(ilun,format)"  character(LEN=5)                    :: nsort, nocpu"
  write(ilun,format)"  character(LEN = 80)                 :: filenamex,filenamey,filenamez"
  write(ilun,format)"  integer::uleidx,uleidy,uleidz"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  !  if(myid .EQ. 1) write(*,*) 'STATUS: starting cooling_fine, ilevel=', ilevel"
  write(ilun,format)"  ! Valeska"
  write(ilun,format)"  !--------------------------------------------------------------------"
  write(ilun,format)"  ! The write option permits us to construct a column density map projected "
  write(ilun,format)"  ! in x, y, and z by calculating the column densities along positive and "
  write(ilun,format)"  ! negative directions with respect to a slice that passes through the "
  write(ilun,format)"  ! respective mid planes."
  write(ilun,format)"  !--------------------------------------------------------------------"
  write(ilun,format)"  if(writing) then"
  write(ilun,format)"     call title(ifout-1, nsort)"
  write(ilun,format)"     call title(myid, nocpu)"
  write(ilun,format)"     filenamex= TRIM(nsort)//'_test_densX_'//TRIM(nocpu)//'.dat'        !ex.:00001_test_densX_00010.dat"
  write(ilun,format)"     filenamey= TRIM(nsort)//'_test_densY_'//TRIM(nocpu)//'.dat'"
  write(ilun,format)"     filenamez= TRIM(nsort)//'_test_densZ_'//TRIM(nocpu)//'.dat'"
  write(ilun,format)"     "
  write(ilun,format)"     uleidx = myid + 100                                                !integer"
  write(ilun,format)"     uleidy = myid + 200"
  write(ilun,format)"     uleidz = myid + 300"
  write(ilun,format)"     "
  write(ilun,format)"     open(unit=uleidx, file=filenamex, form='formatted', status='unknown',position='append')"
  write(ilun,format)"     open(unit=uleidy, file=filenamey, form='formatted', status='unknown',position='append')"
  write(ilun,format)"     open(unit=uleidz, file=filenamez, form='formatted', status='unknown',position='append')"
  write(ilun,format)"  end if"
  write(ilun,format)"  !--------------------------------------------------------------------"
  write(ilun,format)"  ! Valeska"
  write(ilun,format)""
  write(ilun,format)"  ! Operator splitting step for cooling source term"
  write(ilun,format)"  ! by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     call coolfine1(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if((cooling.and..not.neq_chem).and.ilevel==levelmin.and.cosmo)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Computing new cooling table'"
  write(ilun,format)"#ifdef grackle"
  write(ilun,format)"     ! Compute new cooling table at current aexp with grackle"
  write(ilun,format)"     if((1.D0/aexp-1.D0.lt.z_reion).and.(grackle_UVbackground.eq.1).and.(.not.grackle_UVbackground_on)) then"
  write(ilun,format)"        if(myid==1)write(*,*)'Grackle: Activating UV background'"
  write(ilun,format)"        grackle_UVbackground_on = .true."
  write(ilun,format)"        a_value = aexp"
  write(ilun,format)"        call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"        density_units=scale_d"
  write(ilun,format)"        length_units=scale_l"
  write(ilun,format)"        time_units=scale_t"
  write(ilun,format)"        velocity_units=scale_v"
  write(ilun,format)"        ! Initialize the Grackle data"
  write(ilun,format)"         iresult = initialize_grackle(                                &"
  write(ilun,format)"           &     grackle_comoving_coordinates,                        &"
  write(ilun,format)"           &     density_units, length_units,                         &"
  write(ilun,format)"           &     time_units, velocity_units,                          &"
  write(ilun,format)"           &     a_units, a_value,                                    &"
  write(ilun,format)"           &     use_grackle, grackle_with_radiative_cooling,         &"
  write(ilun,format)"           &     TRIM(grackle_data_file),                             &"
  write(ilun,format)"           &     grackle_primordial_chemistry, grackle_metal_cooling, &"
  write(ilun,format)"           &     grackle_UVbackground, grackle_h2_on_dust,            &"
  write(ilun,format)"           &     grackle_cmb_temperature_floor, gamma) "
  write(ilun,format)"     endif"
  write(ilun,format)"#else"
  write(ilun,format)"     call set_table(dble(aexp))"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering cooling_fine for level',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine cooling_fine"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine coolfine1(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  use radiation_commons, ONLY: Erad"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  use rt_parameters, only: nGroups, iGroups"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use rt_cooling_module, only: rt_solve_cooling,iIR,rt_isIRtrap &"
  write(ilun,format)"       ,rt_pressBoost,iIRtrapVar,kappaSc,a_r,is_kIR_T,rt_vc"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel,ngrid"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ind,iskip,idim,nleaf,nx_loc,ix,iy,iz"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(kind=8)::dtcool,nISM,nCOM,damp_factor,cooling_switch,t_blast"
  write(ilun,format)"  real(dp)::polytropic_constant"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_leaf"
  write(ilun,format)"  real(kind=8),dimension(1:nvector),save::nH,T2,T2_new,delta_T2,ekk,err,emag"
  write(ilun,format)"  real(kind=8),dimension(1:nvector),save::T2min,Zsolar,boost"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(kind=8)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  integer::ig,iNp,il  !,ii"
  write(ilun,format)"  real(kind=8),dimension(1:nvector),save:: ekk_new"
  write(ilun,format)"  logical,dimension(1:nvector),save::cooling_on=.true."
  write(ilun,format)"  real(dp)::scale_Np,scale_Fp,work,Npc,fred,Npnew, kScIR, EIR, TR"
  write(ilun,format)"  real(dp),dimension(1:ndim)::Fpnew"
  write(ilun,format)"  real(dp),dimension(nIons, 1:nvector),save:: xion"
  write(ilun,format)"  real(dp),dimension(nGroups, 1:nvector),save:: Np, Np_boost=0d0, dNpdt=0d0"
  write(ilun,format)"  real(dp),dimension(ndim, nGroups, 1:nvector),save:: Fp, Fp_boost, dFpdt"
  write(ilun,format)"  real(dp),dimension(ndim, 1:nvector),save:: p_gas, u_gas"
  write(ilun,format)"  real(kind=8)::f_trap, NIRtot, EIR_trapped, unit_tau, tau, Np2Ep, aexp_loc"
  write(ilun,format)"  real(dp),dimension(nDim, nDim):: tEdd ! Eddington tensor"
  write(ilun,format)"  real(dp),dimension(nDim):: flux "
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef grackle     "
  write(ilun,format)"  real(kind=8) gr_density(nvector), gr_energy(nvector), &"
  write(ilun,format)"  &     gr_x_velocity(nvector), gr_y_velocity(nvector), &"
  write(ilun,format)"  &     gr_z_velocity(nvector), gr_metal_density(nvector), & "
  write(ilun,format)"  &     gr_poly(nvector), gr_floor(nvector)"
  write(ilun,format)"  integer::iresult, solve_chemistry_table, gr_rank"
  write(ilun,format)"  integer,dimension(1:3)::gr_dimension,gr_start,gr_end"
  write(ilun,format)"  real(dp)::density_units,length_units,time_units,velocity_units,temperature_units,a_units=1.0,a_value=1.0,gr_dt"
  write(ilun,format)"  if(cosmo) then"
  write(ilun,format)"     a_value=aexp"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  real(dp) :: barotrop1D,mincolumn_dens"
  write(ilun,format)"  real(dp)                                   :: x0, y0, z0,coeff_chi,cst2, coef"
  write(ilun,format)"  double precision                           :: v_extinction"
  write(ilun,format)"  integer::uleidx,uleidy,uleidz,uleidh,igrid,ii,indc2,iskip2,ind_ll"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-------------- SPHERICAL DIRECTIONS ------------------------------------------------!"
  write(ilun,format)"!  real(dp),dimension(1:nvector,1:ndir)                 :: col_dens                     !"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:NdirExt_m,1:NdirExt_n):: column_dens,column_dens_loc  !"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:NdirExt_m,1:NdirExt_n):: H2column_dens,H2column_dens_loc  ! H2 column density"
  write(ilun,format)"!  real(dp),dimension(ndir)                             :: vcol_dens                    !"
  write(ilun,format)"  real(dp),dimension(1:NdirExt_m,1:NdirExt_n)          :: vcolumn_dens"
  write(ilun,format)"  real(dp),dimension(1:3)                              :: xpos"
  write(ilun,format)"  real(dp)                                             :: dx_cross_int, dx_cross_loc"
  write(ilun,format)"  integer                                              :: index_m,index_n, mmmm,nnnn"
  write(ilun,format)"  integer                                              :: m, n, mloop, nloop, nl   "
  write(ilun,format)"  integer, dimension(1:NdirExt_n)                      :: deltan1, deltan2"
  write(ilun,format)"  integer                                              :: deltam"
  write(ilun,format)"  !-----   simple_chem   --------------------------------------------------------------!"
  write(ilun,format)""
  write(ilun,format)"  !Valeska"
  write(ilun,format)"!  vcol_dens(:) = 0."
  write(ilun,format)"  column_dens(:,:,:) = 0."
  write(ilun,format)"  H2column_dens(:,:,:) = 0."
  write(ilun,format)"  vcolumn_dens(:,:) = 0."
  write(ilun,format)"  "
  write(ilun,format)"  if(writing) then"
  write(ilun,format)"     !---position of reference to calculate the column density maps---"
  write(ilun,format)"     ! we add 1.0D-09 in order to avoid the exact center (there are not cells centered in 0.5L)"
  write(ilun,format)"     x0 = 0.5D0 + 1.0D-09"
  write(ilun,format)"     y0 = 0.5D0 + 1.0D-09"
  write(ilun,format)"     z0 = 0.5D0 + 1.0D-09"
  write(ilun,format)"     "
  write(ilun,format)"     !---Units uleidx, uleidy, uleidz---"
  write(ilun,format)"     uleidx = myid + 100"
  write(ilun,format)"     uleidy = myid + 200"
  write(ilun,format)"     uleidz = myid + 300"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"294 FORMAT(I10,4ES14.5) "
  write(ilun,format)"295 FORMAT(5ES14.5)   "
  write(ilun,format)"296 FORMAT(I10,5ES14.5)                "
  write(ilun,format)"  "
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  "
  write(ilun,format)"  !get the column density within the box from the grid faces"
  write(ilun,format)""
  write(ilun,format)"  !-----   EXTERNAL CONTRIBUTION   -----"
  write(ilun,format)"  if(extinction)  call column_density(ind_grid,ngrid,ilevel,column_dens,H2column_dens) "
  write(ilun,format)"  !Valeska"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  call rt_units(scale_Np, scale_Fp)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Typical ISM density in H/cc"
  write(ilun,format)"  nISM = n_star; nCOM=0d0"
  write(ilun,format)"  if(cosmo)then"
  write(ilun,format)"     nCOM = del_star*omega_b*rhoc*(h0/100.)**2/aexp**3*X/mH"
  write(ilun,format)"  endif"
  write(ilun,format)"  nISM = MAX(nCOM,nISM)"
  write(ilun,format)""
  write(ilun,format)"  ! Polytropic constant for Jeans length related polytropic EOS"
  write(ilun,format)"  if(jeans_ncells>0)then"
  write(ilun,format)"     polytropic_constant=2d0*(boxlen*jeans_ncells*0.5d0**dble(nlevelmax)*scale_l/aexp)**2/ &"
  write(ilun,format)"          & (twopi)*6.67e-8*scale_d*(scale_t/scale_l)**2"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"  if(rt_isIRtrap) then"
  write(ilun,format)"     ! For conversion from photon number density to photon energy density:"
  write(ilun,format)"     Np2Ep = scale_Np * group_egy(iIR) * ev_to_erg                       &"
  write(ilun,format)"          * rt_c_cgs/c_cgs * rt_pressBoost / scale_d / scale_v**2"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  aexp_loc=aexp"
  write(ilun,format)"  ! Allow for high-z UV background in noncosmo sims:"
  write(ilun,format)"  if(.not. cosmo .and. haardt_madau .and. aexp_ini .le. 1.)              &"
  write(ilun,format)"       aexp_loc = aexp_ini"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Gather leaf cells"
  write(ilun,format)"     nleaf=0"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        if(son(ind_cell(i))==0)then"
  write(ilun,format)"           nleaf=nleaf+1"
  write(ilun,format)"           ind_leaf(nleaf)=ind_cell(i)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(nleaf.eq.0)cycle"
  write(ilun,format)""
  write(ilun,format)"     ! Compute rho"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i)=MAX(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute metallicity in solar units"
  write(ilun,format)"     if(metal)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           Zsolar(i)=uold(ind_leaf(i),imetal)/nH(i)/0.02"
  write(ilun,format)"        end do"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           Zsolar(i)=z_ave"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     ! Floor density (prone to go negative with strong rad. pressure):"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        uold(ind_leaf(i),1) = max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Initialise gas momentum and velocity for photon momentum abs.:"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        p_gas(:,i) = uold(ind_leaf(i),2:ndim+1) * scale_d * scale_v"
  write(ilun,format)"        u_gas(:,i) = uold(ind_leaf(i),2:ndim+1) &"
  write(ilun,format)"                     /uold(ind_leaf(i),1) * scale_v"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"     if(rt_isIRtrap) then  ! Gather also trapped photons for solve_cooling"
  write(ilun,format)"        iNp=iGroups(iIR)"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           il=ind_leaf(i)"
  write(ilun,format)"           rtuold(il,iNp) = rtuold(il,iNp) + uold(il,iIRtrapVar)/Np2Ep"
  write(ilun,format)"           if(rt_smooth) &"
  write(ilun,format)"                rtunew(il,iNp)= rtunew(il,iNp) + uold(il,iIRtrapVar)/Np2Ep"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     if(rt_vc) then      ! Add/remove radiation work on gas. Eq A6 in RT15"
  write(ilun,format)"        iNp=iGroups(iIR)"
  write(ilun,format)"        do i=1,nleaf "
  write(ilun,format)"           il=ind_leaf(i)"
  write(ilun,format)"           NIRtot = rtuold(il,iNp)"
  write(ilun,format)"           kScIR  = kappaSc(iIR)  "
  write(ilun,format)"           if(is_kIR_T) then                      !      k_IR depends on T"
  write(ilun,format)"              EIR = group_egy(iIR) * ev_to_erg * NIRtot *scale_Np"
  write(ilun,format)"              TR = max(T2_min_fix,(EIR*rt_c_cgs/c_cgs/a_r)**0.25)"
  write(ilun,format)"              kScIR  = kappaSc(iIR)  * (TR/10d0)**2"
  write(ilun,format)"           endif"
  write(ilun,format)"           kScIR = kScIR*scale_d*scale_l"
  write(ilun,format)"           flux = rtuold(il,iNp+1:iNp+ndim)"
  write(ilun,format)"           work = scale_v/c_cgs * kScIR * sum(uold(il,2:ndim+1)*flux) &"
  write(ilun,format)"                * Zsolar(i) * dtnew(ilevel)       ! Eq A6"
  write(ilun,format)"           "
  write(ilun,format)"           uold(il,ndim+2) = uold(il,ndim+2) &    ! Add work to gas energy"
  write(ilun,format)"                + work * group_egy(iIR) &"
  write(ilun,format)"                * ev_to_erg / scale_d / scale_v**2 / scale_l**3"
  write(ilun,format)"           "
  write(ilun,format)"           rtuold(il,iNp) = rtuold(il,iNp) - work !Remove from rad density"
  write(ilun,format)"           rtuold(il,iNp) = max(rtuold(il,iNp),smallnp)"
  write(ilun,format)"           call reduce_flux(rtuold(il,iNp+1:iNp+ndim),rtuold(il,iNp)*rt_c)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"        "
  write(ilun,format)"     ! Compute thermal pressure"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=uold(ind_leaf(i),ndim+2)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        ekk(i)=0.0d0"
  write(ilun,format)"     end do"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           ekk(i)=ekk(i)+0.5*uold(ind_leaf(i),idim+1)**2/nH(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        err(i)=0.0d0"
  write(ilun,format)"     end do"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"     do irad=0,nener-1"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           err(i)=err(i)+uold(ind_leaf(i),inener+irad)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        emag(i)=0.0d0"
  write(ilun,format)"     end do"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           emag(i)=emag(i)+0.125d0*(uold(ind_leaf(i),idim+ndim+2)+uold(ind_leaf(i),idim+nvar))**2"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=(gamma-1.0)*(T2(i)-ekk(i)-err(i)-emag(i))"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute T2=T/mu in Kelvin"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=T2(i)/nH(i)*scale_T2"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute nH in H/cc"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i)=nH(i)*scale_nH"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute radiation boost factor"
  write(ilun,format)"     if(self_shielding)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=MAX(exp(-nH(i)/0.01),1.0D-20)"
  write(ilun,format)"        end do"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"     else if (aton) then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=MAX(Erad(ind_leaf(i))/J0simple(aexp), &"
  write(ilun,format)"                &                   J0min/J0simple(aexp) )"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=1.0"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     ! Compute temperature from polytrope EOS"
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     if(jeans_ncells>0)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2min(i) = nH(i)*polytropic_constant*scale_T2"
  write(ilun,format)"        end do"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2min(i) = T2_star*(nH(i)/nISM)**(g_star-1.0)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     ! You can put your own polytrope EOS here"
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     ! Compute temperature from polytrope"
  write(ilun,format)"     if(isothermal)then"
  write(ilun,format)"        ! Set to T2_star"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2min(i) = T2_star"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     if(barotrop)then"
  write(ilun,format)"        do i=1,nleaf  "
  write(ilun,format)"           T2min(i) = barotrop1D(nH(i)*scale_d) "
  write(ilun,format)"        enddo"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(cooling)then"
  write(ilun,format)"        ! Compute thermal temperature by substracting polytrope"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2(i) = min(max(T2(i)-T2min(i),T2_min_fix),T2max)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute cooling time step in second"
  write(ilun,format)"     dtcool = dtnew(ilevel)*scale_t"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(neq_chem) then"
  write(ilun,format)"        ! Get the ionization fractions"
  write(ilun,format)"        do ii=0,nIons-1"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              xion(1+ii,i) = uold(ind_leaf(i),iIons+ii)/uold(ind_leaf(i),1)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Get photon densities and flux magnitudes"
  write(ilun,format)"        do ig=1,nGroups"
  write(ilun,format)"           iNp=iGroups(ig)"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              il=ind_leaf(i)"
  write(ilun,format)"              Np(ig,i)        = scale_Np * rtuold(il,iNp)"
  write(ilun,format)"              Fp(1:ndim, ig, i) = scale_Fp * rtuold(il,iNp+1:iNp+ndim)"
  write(ilun,format)"           enddo"
  write(ilun,format)"           if(rt_smooth) then                           ! Smooth RT update"
  write(ilun,format)"              do i=1,nleaf !Calc addition per sec to Np, Fp for current dt"
  write(ilun,format)"                 il=ind_leaf(i)"
  write(ilun,format)"                 Npnew = scale_Np * rtunew(il,iNp)"
  write(ilun,format)"                 Fpnew = scale_Fp * rtunew(il,iNp+1:iNp+ndim)"
  write(ilun,format)"                 dNpdt(ig,i)   = (Npnew - Np(ig,i)) / dtcool"
  write(ilun,format)"                 dFpdt(:,ig,i) = (Fpnew - Fp(:,ig,i)) / dtcool"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        if(cooling .and. delayed_cooling) then"
  write(ilun,format)"           cooling_on(1:nleaf)=.true."
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              if(uold(ind_leaf(i),idelay)/uold(ind_leaf(i),1) .gt. 1d-3) &"
  write(ilun,format)"                   cooling_on(i)=.false."
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(isothermal)cooling_on(1:nleaf)=.false."
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     if(rt_vc) then ! Do the Lorentz boost. Eqs A4 and A5. in RT15"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           do ig=1,nGroups"
  write(ilun,format)"              Npc=Np(ig,i)*rt_c_cgs"
  write(ilun,format)"              call cmp_Eddington_tensor(Npc,Fp(:,ig,i),tEdd)"
  write(ilun,format)"              Np_boost(ig,i) = - 2d0/c_cgs/rt_c_cgs * sum(u_gas(:,i)*Fp(:,ig,i))"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 Fp_boost(idim,ig,i) =  &"
  write(ilun,format)"                      -u_gas(idim,i)*Np(ig,i) * rt_c_cgs/c_cgs &"
  write(ilun,format)"                      -sum(u_gas(:,i)*tEdd(idim,:))*Np(ig,i)*rt_c_cgs/c_cgs"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           Np(:,i)   = Np(:,i) + Np_boost(:,i)"
  write(ilun,format)"           Fp(:,:,i) = Fp(:,:,i) + Fp_boost(:,:,i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ! grackle tabular cooling"
  write(ilun,format)"#ifdef grackle"
  write(ilun,format)"     if(cosmo) then"
  write(ilun,format)"        a_value=aexp"
  write(ilun,format)"     endif"
  write(ilun,format)"     gr_rank = 3"
  write(ilun,format)"     do i = 1, gr_rank"
  write(ilun,format)"        gr_dimension(i) = 1"
  write(ilun,format)"        gr_start(i) = 0"
  write(ilun,format)"        gr_end(i) = 0"
  write(ilun,format)"     enddo"
  write(ilun,format)"     gr_dimension(1) = nvector"
  write(ilun,format)"     gr_end(1) = nleaf - 1"
  write(ilun,format)"     ! set units"
  write(ilun,format)"     density_units=scale_d"
  write(ilun,format)"     length_units=scale_l"
  write(ilun,format)"     time_units=scale_t"
  write(ilun,format)"     velocity_units=scale_v"
  write(ilun,format)"     temperature_units=scale_T2"
  write(ilun,format)"     do i = 1, nleaf"
  write(ilun,format)"        gr_density(i) = max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"        if(metal)then"
  write(ilun,format)"           gr_metal_density(i) = uold(ind_leaf(i),imetal)"
  write(ilun,format)"        else"
  write(ilun,format)"           gr_metal_density(i) = uold(ind_leaf(i),1)*0.02*z_ave"
  write(ilun,format)"        endif"
  write(ilun,format)"        gr_x_velocity(i) = uold(ind_leaf(i),2)/max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"        gr_y_velocity(i) = uold(ind_leaf(i),3)/max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"        gr_z_velocity(i) = uold(ind_leaf(i),4)/max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"        gr_floor(i)  = 1.0*nH(i)/scale_nH/scale_T2/(gamma-1.0)"
  write(ilun,format)"        gr_poly(i)   = T2min(i)*nH(i)/scale_nH/scale_T2/(gamma-1.0)"
  write(ilun,format)"        gr_energy(i) = uold(ind_leaf(i),ndim+2)-ekk(i)-gr_poly(i)"
  write(ilun,format)"        gr_energy(i) = MAX(gr_energy(i),gr_floor(i))"
  write(ilun,format)"        gr_energy(i) = gr_energy(i)/max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     gr_dt = dtnew(ilevel)"
  write(ilun,format)"    "
  write(ilun,format)"     iresult = solve_chemistry_table(    &"
  write(ilun,format)"     &     grackle_comoving_coordinates, &"
  write(ilun,format)"     &     density_units, length_units,  &"
  write(ilun,format)"     &     time_units, velocity_units,   &"
  write(ilun,format)"     &     a_units, a_value, gr_dt,      &"
  write(ilun,format)"     &     gr_rank, gr_dimension,        &"
  write(ilun,format)"     &     gr_start, gr_end,             &"
  write(ilun,format)"     &     gr_density, gr_energy,        &"
  write(ilun,format)"     &     gr_x_velocity, gr_y_velocity, gr_z_velocity, &"
  write(ilun,format)"     &     gr_metal_density)"
  write(ilun,format)""
  write(ilun,format)"     do i = 1, nleaf"
  write(ilun,format)"        T2_new(i) = gr_energy(i)*scale_T2*(gamma-1.0)"
  write(ilun,format)"     end do"
  write(ilun,format)"     delta_T2(1:nleaf) = T2_new(1:nleaf) - T2(1:nleaf)"
  write(ilun,format)"#else"
  write(ilun,format)"     ! Compute net cooling at constant nH"
  write(ilun,format)"     if(cooling.and..not.neq_chem)then"
  write(ilun,format)"        call solve_cooling(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf)"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(neq_chem) then"
  write(ilun,format)"        T2_new(1:nleaf) = T2(1:nleaf)"
  write(ilun,format)"        call rt_solve_cooling(T2_new, xion, Np, Fp, p_gas, dNpdt, dFpdt  &"
  write(ilun,format)"                         , nH, cooling_on, Zsolar, dtcool, aexp_loc,nleaf)"
  write(ilun,format)"        delta_T2(1:nleaf) = T2_new(1:nleaf) - T2(1:nleaf)"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(.not. static) then"
  write(ilun,format)"        ! Update gas momentum and kinetic energy:"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),2:1+ndim) = p_gas(:,i) /scale_d /scale_v"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Energy update =================================================="
  write(ilun,format)"        ! Calculate NEW pressure from updated momentum"
  write(ilun,format)"        ekk_new(1:nleaf) = 0d0"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              ekk_new(i) = ekk_new(i) &"
  write(ilun,format)"                   + 0.5*uold(ind_leaf(i),idim+1)**2 / uold(ind_leaf(i),1)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,nleaf                                   "
  write(ilun,format)"           ! Update the pressure variable with the new kinetic energy:"
  write(ilun,format)"           uold(ind_leaf(i),ndim+2) = uold(ind_leaf(i),ndim+2)           &"
  write(ilun,format)"                                    - ekk(i) + ekk_new(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,nleaf                                   "
  write(ilun,format)"           ekk(i)=ekk_new(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     "
  write(ilun,format)"#if NGROUPS>0 "
  write(ilun,format)"        if(rt_vc) then ! Photon work: subtract from the IR ONLY radiation"
  write(ilun,format)"           do i=1,nleaf                                   "
  write(ilun,format)"              Np(iIR,i) = Np(iIR,i) + (ekk(i) - ekk_new(i))              &"
  write(ilun,format)"                   /scale_d/scale_v**2 / group_egy(iIR) / ev_to_erg"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"#endif"
  write(ilun,format)"        ! End energy update =============================================="
  write(ilun,format)"     endif ! if(.not. static)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute rho"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i) = nH(i)/scale_nH"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Deal with cooling"
  write(ilun,format)"     if(cooling.or.neq_chem)then"
  write(ilun,format)"        ! Compute net energy sink"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           delta_T2(i) = delta_T2(i)*nH(i)/scale_T2/(gamma-1.0)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Compute initial fluid internal energy"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2(i) = T2(i)*nH(i)/scale_T2/(gamma-1.0)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Turn off cooling in blast wave regions"
  write(ilun,format)"        if(delayed_cooling)then"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              cooling_switch = uold(ind_leaf(i),idelay)/max(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"              if(cooling_switch > 1d-3)then"
  write(ilun,format)"                 delta_T2(i) = MAX(delta_T2(i),real(0,kind=dp))"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute polytrope internal energy"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2min(i) = T2min(i)*nH(i)/scale_T2/(gamma-1.0)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Update fluid internal energy"
  write(ilun,format)"     if(cooling.or.neq_chem)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2(i) = T2(i) + delta_T2(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Update total fluid energy"
  write(ilun,format)"     if(isothermal)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),ndim+2) = T2min(i) + ekk(i) + err(i) + emag(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     else if(cooling .or. neq_chem)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),ndim+2) = T2(i) + T2min(i) + ekk(i) + err(i) + emag(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Update delayed cooling switch"
  write(ilun,format)"     if(delayed_cooling)then"
  write(ilun,format)"        t_blast=t_diss*1d6*(365.*24.*3600.)"
  write(ilun,format)"        damp_factor=exp(-dtcool/t_blast)"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),idelay)=uold(ind_leaf(i),idelay)*damp_factor"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(neq_chem) then"
  write(ilun,format)"        ! Update ionization fraction"
  write(ilun,format)"        do ii=0,nIons-1"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              uold(ind_leaf(i),iIons+ii) = xion(1+ii,i)*nH(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"#if NGROUPS>0 "
  write(ilun,format)"     if(rt) then"
  write(ilun,format)"        ! Update photon densities and flux magnitudes"
  write(ilun,format)"        do ig=1,nGroups"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              rtuold(ind_leaf(i),iGroups(ig)) = (Np(ig,i)-Np_boost(ig,i)) /scale_Np"
  write(ilun,format)"              rtuold(ind_leaf(i),iGroups(ig)) = &"
  write(ilun,format)"                   max(rtuold(ind_leaf(i),iGroups(ig)),smallNp)"
  write(ilun,format)"              rtuold(ind_leaf(i),iGroups(ig)+1:iGroups(ig)+ndim)         &"
  write(ilun,format)"                               = (Fp(1:ndim,ig,i)-Fp_boost(1:ndim,ig,i)) /scale_Fp"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Split IR photons into trapped and freeflowing"
  write(ilun,format)"     if(rt_isIRtrap) then"
  write(ilun,format)"        if(nener .le. 0) then"
  write(ilun,format)"           print*,'Trying to store E_trapped pressure, but NERAD too small!!'"
  write(ilun,format)"           STOP"
  write(ilun,format)"        endif"
  write(ilun,format)"        iNp=iGroups(iIR)"
  write(ilun,format)"        unit_tau = 1.5d0 * dx_loc * scale_d * scale_l"
  write(ilun,format)"        do i=1,nleaf                                                    "
  write(ilun,format)"           il=ind_leaf(i)                                               "
  write(ilun,format)"           NIRtot =max(rtuold(il,iNp),smallNp)      ! Total photon density"
  write(ilun,format)"           kScIR  = kappaSc(iIR)                                          "
  write(ilun,format)"           if(is_kIR_T) then                        !    k_IR depends on T"
  write(ilun,format)"              EIR = group_egy(iIR) * ev_to_erg * NIRtot *scale_Np  "
  write(ilun,format)"              TR = max(T2_min_fix,(EIR*rt_c_cgs/c_cgs/a_r)**0.25)"
  write(ilun,format)"              kScIR  = kappaSc(iIR) * (TR/10d0)**2               "
  write(ilun,format)"           endif                                                        "
  write(ilun,format)"           tau = nH(i) * Zsolar(i) * unit_tau * kScIR                  "
  write(ilun,format)"           f_trap = 0d0             ! Fraction IR photons that are trapped"
  write(ilun,format)"           if(tau .gt. 0d0) f_trap = min(max(exp(-1d0/tau), 0d0), 1d0) "
  write(ilun,format)"           ! Update streaming photons, trapped photons, and tot energy:"
  write(ilun,format)"           rtuold(il,iNp) = max(smallnp,(1d0-f_trap) * NIRtot) ! Streaming"
  write(ilun,format)"           rtuold(il,iNp+1:iNp+ndim) = &            ! Limit streaming flux"
  write(ilun,format)"                                  rtuold(il,iNp+1:iNp+ndim) * (1d0-f_trap)"
  write(ilun,format)"           EIR_trapped = max(0d0, NIRtot-rtuold(il,iNp)) * Np2Ep ! Trapped"
  write(ilun,format)"           ! Update tot energy due to change in trapped radiation energy:"
  write(ilun,format)"           uold(il,ndim+2)=uold(il,ndim+2)-uold(il,iIRtrapVar)+EIR_trapped"
  write(ilun,format)"           ! Update the trapped photon energy:"
  write(ilun,format)"           uold(il,iIRtrapVar) = EIR_trapped"
  write(ilun,format)""
  write(ilun,format)"           call reduce_flux(rtuold(il,iNp+1:iNp+ndim),rtuold(il,iNp)*rt_c)"
  write(ilun,format)"        end do ! i=1,nleaf                                                 "
  write(ilun,format)""
  write(ilun,format)"     endif  !rt_isIRtrap     "
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     if(barotrop)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),2+ndim) = T2min(i) + ekk(i) + err(i) + emag(i)"
  write(ilun,format)"           uold(ind_leaf(i),nvar  ) = T2min(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"end subroutine coolfine1"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"subroutine cmp_Eddington_tensor(Npc,Fp,T_Edd)"
  write(ilun,format)"  "
  write(ilun,format)"! Compute Eddington tensor for given radiation variables"
  write(ilun,format)"! Npc     => Photon number density times light speed"
  write(ilun,format)"! Fp     => Photon number flux"
  write(ilun,format)"! T_Edd  <= Returned Eddington tensor"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::Npc"
  write(ilun,format)"  real(dp),dimension(1:ndim)::Fp ,u"
  write(ilun,format)"  real(dp),dimension(1:ndim,1:ndim)::T_Edd "
  write(ilun,format)"  real(dp)::iterm,oterm,Np_c_sq,Fp_sq,fred_sq,chi"
  write(ilun,format)"  integer::p,q"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  if(Npc .le. 0.d0) then"
  write(ilun,format)"     write(*,*)'negative photon density in cmp_Eddington_tensor. -EXITING-'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  T_Edd(:,:) = 0.d0   "
  write(ilun,format)"  Np_c_sq = Npc**2        "
  write(ilun,format)"  Fp_sq = sum(Fp**2)              !  Sq. photon flux magnitude"
  write(ilun,format)"  u(:) = 0.d0                           !           Flux unit vector"
  write(ilun,format)"  if(Fp_sq .gt. 0.d0) u(:) = Fp/sqrt(Fp_sq)  "
  write(ilun,format)"  fred_sq = Fp_sq/Np_c_sq           !      Reduced flux, squared"
  write(ilun,format)"  chi = max(4.d0-3.d0*fred_sq, 0.d0)   !           Eddington factor"
  write(ilun,format)"  chi = (3.d0+ 4.d0*fred_sq)/(5.d0 + 2.d0*sqrt(chi))"
  write(ilun,format)"  iterm = (1.d0-chi)/2.d0               !    Identity term in tensor"
  write(ilun,format)"  oterm = (3.d0*chi-1.d0)/2.d0          !         Outer product term"
  write(ilun,format)"  do p = 1, ndim"
  write(ilun,format)"     do q = 1, ndim"
  write(ilun,format)"        T_Edd(p,q) = oterm * u(p) * u(q)"
  write(ilun,format)"     enddo"
  write(ilun,format)"     T_Edd(p,p) = T_Edd(p,p) + iterm"
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine cmp_Eddington_tensor"
  write(ilun,format)"#endif"
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!====================================================================================================="
  write(ilun,format)"!====================================================================================================="
  write(ilun,format)"!====================================================================================================="
  write(ilun,format)"!====================================================================================================="
  write(ilun,format)"subroutine pressure_eos(rho_temp,Enint_temp,Peos)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use cooling_module      ,only:kB,mH"
  write(ilun,format)"  use radiation_parameters,only:mu_gas"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the pressure from the density and "
  write(ilun,format)"  ! internal volumic energy. Inputs/output are in code units"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  integer::i_t,i_r,i"
  write(ilun,format)"  real(dp), intent(in) :: Enint_temp,rho_temp"
  write(ilun,format)"  real(dp):: Enint,rho"
  write(ilun,format)"  real(dp), intent(out):: Peos"
  write(ilun,format)"  real(dp)::logr,tt,uu,y1,y2,y3,y4"
  write(ilun,format)"  real(dp):: le,lr"
  write(ilun,format)"  real(dp):: dd1,dd2,de1,de2"
  write(ilun,format)"  integer :: ir,ie"
  write(ilun,format)"  real(dp):: xx,drho,dener"
  write(ilun,format)""
  write(ilun,format)"  if(eos)then"
  write(ilun,format)"  rho = rho_temp * scale_d"
  write(ilun,format)"  Enint   = Enint_temp * scale_d*scale_v**2 "
  write(ilun,format)"  "
  write(ilun,format)"  drho  = (rhomax-rhomin)/float(nRho)"
  write(ilun,format)"  lr = 0.5d0 + (log10(rho )- rhomin )/drho"
  write(ilun,format)""
  write(ilun,format)"  if (lr .ge. Nrho) then"
  write(ilun,format)"     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ir = floor(lr)"
  write(ilun,format)""
  write(ilun,format)"  dEner = ( Emax  -   emin)/float(nEnergy)"
  write(ilun,format)"  le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner"
  write(ilun,format)""
  write(ilun,format)"  if ((le .ge. nEnergy) ) then"
  write(ilun,format)"     write(*,*)'intermaxE_P',Enint ,Ener_eos(ir,nEnergy)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ie = floor(le)"
  write(ilun,format)"  if  (ir < 1 .or. ie < 1 .or. ir>nrho .or. ie>nEnergy) then"
  write(ilun,format)"     write(*,*) 'inter_pressure hors limite i,ir,ie = ',ir,ie,rho ,Enint "
  write(ilun,format)"     ir=1.0d0"
  write(ilun,format)"     ie=1.0d0"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  dd1 = lr - float(ir)"
  write(ilun,format)"  dd2 = le - float(ie)"
  write(ilun,format)""
  write(ilun,format)"  de1 = 1.0d0 - dd1"
  write(ilun,format)"  de2 = 1.0d0 - dd2"
  write(ilun,format)""
  write(ilun,format)"  Peos=0.d0"
  write(ilun,format)""
  write(ilun,format)"  Peos = Peos + de1*de2*P_eos(ir  ,ie  )"
  write(ilun,format)"  Peos = Peos + dd1*de2*P_eos(ir+1,ie  )"
  write(ilun,format)"  Peos = Peos + de1*dd2*P_eos(ir  ,ie+1)"
  write(ilun,format)"  Peos = Peos + dd1*dd2*P_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"  Peos = Peos / (scale_d *scale_v**2) ! give P in code units"
  write(ilun,format)""
  write(ilun,format)"  xx =  P_eos(ir,ie)*P_eos(ir+1,ie)*P_eos(ir,ie+1)*P_eos(ir+1,ie+1) "
  write(ilun,format)""
  write(ilun,format)"  if (xx .eq. 0.0d0 ) then"
  write(ilun,format)"     write(*,*) '**************** P_eos ****************'"
  write(ilun,format)"     write(*,*) 'ir,ie,i =',ir,ie,i"
  write(ilun,format)"     write(*,*) rho ,Enint "
  write(ilun,format)"     write(*,*) P_eos(ir,ie  ), P_eos(ir+1,ie  ) "
  write(ilun,format)"     write(*,*) P_eos(ir,ie+1), P_eos(ir+1,ie+1)"
  write(ilun,format)"     write(*,*) P_eos(ir,ie+2), P_eos(ir-1,ie+1)"
  write(ilun,format)"     write(*,*) 0.25*(P_eos(ir,ie+2) + P_eos(ir-1,ie+1) +   P_eos(ir+1,ie+1) +  P_eos(ir,ie))"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"else"
  write(ilun,format)"     Peos = (gamma-1.d0)*Enint_temp"
  write(ilun,format)"end if"
  write(ilun,format)"end subroutine pressure_eos"
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"subroutine temperature_eos(rho_temp,Enint_temp,Teos,ht)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use cooling_module      ,only:kB,mH"
  write(ilun,format)"  use radiation_parameters,only:mu_gas"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the temperature from the density and "
  write(ilun,format)"  ! internal volumic energy. Inputs/output are in code units."
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  integer::i_t,i_r,i"
  write(ilun,format)"  integer::ht"
  write(ilun,format)"  real(dp), intent(in) :: Enint_temp,rho_temp"
  write(ilun,format)"  real(dp):: Enint,rho"
  write(ilun,format)"  real(dp), intent(out):: Teos"
  write(ilun,format)"  real(dp)::logr,tt,uu,y1,y2,y3,y4"
  write(ilun,format)"  real(dp):: le,lr"
  write(ilun,format)"  real(dp):: dd1,dd2,de1,de2"
  write(ilun,format)"  integer :: ir,ie"
  write(ilun,format)"  real(dp):: xx,drho,dener"
  write(ilun,format)"  real(dp) :: barotrop1D"
  write(ilun,format)""
  write(ilun,format)"if(eos)then"
  write(ilun,format)"  if (enint_temp ==0.d0) then"
  write(ilun,format)"     teos=0.d0"
  write(ilun,format)"  else"
  write(ilun,format)"     ht=0"
  write(ilun,format)""
  write(ilun,format)"     rho   = rho_temp * scale_d             "
  write(ilun,format)"     Enint = Enint_temp * scale_d*scale_v**2"
  write(ilun,format)""
  write(ilun,format)"     drho  = (rhomax-rhomin)/float(nRho)"
  write(ilun,format)"     lr = 0.5d0 + (log10(rho )- rhomin )/drho"
  write(ilun,format)""
  write(ilun,format)"     if (lr .ge. Nrho) then"
  write(ilun,format)"        write(*,*)'pb 1'"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)"     ir = floor(lr)"
  write(ilun,format)""
  write(ilun,format)"     dEner = ( Emax  -   emin)/float(nEnergy)"
  write(ilun,format)"     le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner"
  write(ilun,format)""
  write(ilun,format)"     if ((le .ge. nEnergy) ) then"
  write(ilun,format)"        write(*,*)'pb 2'"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ie = floor(le)"
  write(ilun,format)"     if  (ir < 1 .or. ie < 1 ) then"
  write(ilun,format)"        write(*,*) 'inter_tp hors limite ir,ie,rho,enint = ',ir,ie,rho ,Enint "
  write(ilun,format)"        ir=1.0d0"
  write(ilun,format)"        ie=1.0d0"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     dd1 = lr - float(ir)"
  write(ilun,format)"     dd2 = le - float(ie)"
  write(ilun,format)""
  write(ilun,format)"     de1 = 1.0d0 - dd1"
  write(ilun,format)"     de2 = 1.0d0 - dd2"
  write(ilun,format)""
  write(ilun,format)"     Teos=0.d0"
  write(ilun,format)""
  write(ilun,format)"     Teos = Teos + de1*de2*Temp_eos(ir  ,ie  )"
  write(ilun,format)"     Teos = Teos + dd1*de2*Temp_eos(ir+1,ie  )"
  write(ilun,format)"     Teos = Teos + de1*dd2*Temp_eos(ir  ,ie+1)"
  write(ilun,format)"     Teos = Teos + dd1*dd2*Temp_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"     Teos = Teos ! give T in K"
  write(ilun,format)""
  write(ilun,format)"     xx =  Temp_eos(ir,ie)*Temp_eos(ir+1,ie)*Temp_eos(ir,ie+1)*Temp_eos(ir+1,ie+1) "
  write(ilun,format)""
  write(ilun,format)"     if (xx .eq. 0.0d0 ) then"
  write(ilun,format)"        ht=1"
  write(ilun,format)"        !     write(*,*) '**************** Pb_eos ****************'"
  write(ilun,format)"        !     write(*,*) 'ir,ie,i =',ir,ie,i"
  write(ilun,format)"        !     write(*,*) rho ,Enint "
  write(ilun,format)"        !     write(*,*) Temp_eos(ir,ie  ), Temp_eos(ir+1,ie  ) "
  write(ilun,format)"        !     write(*,*) Temp_eos(ir,ie+1), Temp_eos(ir+1,ie+1)"
  write(ilun,format)"        !     write(*,*) Temp_eos(ir,ie+2), Temp_eos(ir-1,ie+1)"
  write(ilun,format)"        !     write(*,*) 0.25*(Temp_eos(ir,ie+2) + Temp_eos(ir-1,ie+1) +   Temp_eos(ir+1,ie+1) +  Temp_eos(ir,ie))"
  write(ilun,format)"        !     stop"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  else if(barotrop)then"
  write(ilun,format)"     Teos=barotrop1D(rho_temp*scale_d)"
  write(ilun,format)"  else "
  write(ilun,format)"     rho   = rho_temp*scale_d"
  write(ilun,format)"     Enint = Enint_temp*scale_d*scale_v**2 "
  write(ilun,format)""
  write(ilun,format)"     Teos = Enint/(rho*kB/(mu_gas*mH*(gamma-1.0d0)))"
  write(ilun,format)"     "
  write(ilun,format)"     ht=1"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine temperature_eos"
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"!==========================================================================================="
  write(ilun,format)"subroutine enerint_eos(rho_temp,temp_temp,Eeos)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use cooling_module      ,only:kB,mH"
  write(ilun,format)"  use radiation_parameters,only:mu_gas"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the internal volumic energy from  "
  write(ilun,format)"  ! the density and the temperature. Inputs/output are in code units."
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  integer::i_t,i_r,i"
  write(ilun,format)"  real(dp), intent(in) :: temp_temp,rho_temp"
  write(ilun,format)"  real(dp):: temp,rho"
  write(ilun,format)"  real(dp), intent(out):: Eeos"
  write(ilun,format)"  real(dp)::logr,tt,uu,y1,y2,y3,y4"
  write(ilun,format)"  real(dp):: le,lr"
  write(ilun,format)"  real(dp):: dd1,dd2,de1,de2"
  write(ilun,format)"  integer :: ir,ie"
  write(ilun,format)"  real(dp):: xx,drho,dtemp"
  write(ilun,format)""
  write(ilun,format)"  if(eos)then"
  write(ilun,format)"     rho = rho_temp * scale_d"
  write(ilun,format)"     temp   = temp_temp"
  write(ilun,format)"     "
  write(ilun,format)"     drho  = (rhomax-rhomin)/float(nRho)"
  write(ilun,format)"     lr = 0.5d0 + (log10(rho )- rhomin )/drho"
  write(ilun,format)""
  write(ilun,format)"  if (lr .ge. Nrho) then"
  write(ilun,format)"     write(*,*)'pb 11'"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ir = floor(lr)"
  write(ilun,format)""
  write(ilun,format)"  dtemp = ( log10(Tmax)  -   log10(Tmin))/float(ntemp)"
  write(ilun,format)"  le = 1.0d0 + (log10(temp) - log10(Tmin))/dtemp"
  write(ilun,format)""
  write(ilun,format)"  if ((le .ge. ntemp) ) then"
  write(ilun,format)"     write(*,*)'pb 22'"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ie = floor(le)"
  write(ilun,format)"  if  (ir < 1 .or. ie < 1 ) then"
  write(ilun,format)"     write(*,*) 'inter_ener hors limite ir,ie,rho,enint cooling= ',ir,ie,rho ,temp"
  write(ilun,format)"     ir=1.0d0"
  write(ilun,format)"     ie=1.0d0"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  dd1 = lr - float(ir)"
  write(ilun,format)"  dd2 = le - float(ie)"
  write(ilun,format)""
  write(ilun,format)"  de1 = 1.0d0 - dd1"
  write(ilun,format)"  de2 = 1.0d0 - dd2"
  write(ilun,format)""
  write(ilun,format)"  Eeos=0.d0"
  write(ilun,format)""
  write(ilun,format)"  Eeos = Eeos + de1*de2*eint_eos(ir  ,ie  )"
  write(ilun,format)"  Eeos = Eeos + dd1*de2*eint_eos(ir+1,ie  )"
  write(ilun,format)"  Eeos = Eeos + de1*dd2*eint_eos(ir  ,ie+1)"
  write(ilun,format)"  Eeos = Eeos + dd1*dd2*eint_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"  Eeos = Eeos / (scale_d*scale_v**2) ! give energy in code units"
  write(ilun,format)""
  write(ilun,format)"  xx =  eint_eos(ir,ie)*eint_eos(ir+1,ie)*eint_eos(ir,ie+1)*eint_eos(ir+1,ie+1) "
  write(ilun,format)""
  write(ilun,format)"  if (xx .eq. 0.0d0 ) then"
  write(ilun,format)"     !     write(*,*) '**************** Pb_eos ****************'"
  write(ilun,format)"     !     write(*,*) 'ir,ie,i =',ir,ie,i"
  write(ilun,format)"     !     write(*,*) rho ,Enint "
  write(ilun,format)"     !     write(*,*) eint_eos(ir,ie  ), eint_eos(ir+1,ie  ) "
  write(ilun,format)"     !     write(*,*) eint_eos(ir,ie+1), eint_eos(ir+1,ie+1)"
  write(ilun,format)"     !     write(*,*) eint_eos(ir,ie+2), eint_eos(ir-1,ie+1)"
  write(ilun,format)"     !     write(*,*) 0.25*(eint_eos(ir,ie+2) + eint_eos(ir-1,ie+1) +   eint_eos(ir+1,ie+1) +  eint_eos(ir,ie))"
  write(ilun,format)"     !     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"else"
  write(ilun,format)"  rho  = rho_temp * scale_d"
  write(ilun,format)"  temp = temp_temp"
  write(ilun,format)""
  write(ilun,format)"  Eeos = rho*kB/(mu_gas*mH*(gamma-1.0))*temp/(scale_d*scale_v**2)"
  write(ilun,format)"end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine enerint_eos"
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"!=================================================================================="
  write(ilun,format)"subroutine soundspeed_eos(rho_temp,Enint_temp,Cseos)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use cooling_module      ,only:kB,mH"
  write(ilun,format)"  use radiation_parameters,only:mu_gas"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the sound speed from the internal volumic energy "
  write(ilun,format)"  ! and the temperature. Inputs/output are in code units."
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  integer::i_t,i_r,i"
  write(ilun,format)"  real(dp), intent(in) :: Enint_temp,rho_temp"
  write(ilun,format)"  real(dp):: Enint,rho"
  write(ilun,format)"  real(dp), intent(out):: Cseos"
  write(ilun,format)"  real(dp)::logr,tt,uu,y1,y2,y3,y4"
  write(ilun,format)"  real(dp):: le,lr"
  write(ilun,format)"  real(dp):: dd1,dd2,de1,de2"
  write(ilun,format)"  integer :: ir,ie"
  write(ilun,format)"  real(dp):: xx,drho,dener"
  write(ilun,format)""
  write(ilun,format)"if(eos)then"
  write(ilun,format)"   rho = rho_temp * scale_d"
  write(ilun,format)"  Enint   = Enint_temp * scale_d*scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  drho  = (rhomax-rhomin)/float(nRho)"
  write(ilun,format)"  lr = 0.50d0 + (log10(rho )- rhomin )/drho"
  write(ilun,format)""
  write(ilun,format)"  if (lr .ge. Nrho) then"
  write(ilun,format)"     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ir = floor(lr)"
  write(ilun,format)""
  write(ilun,format)"  dEner = ( Emax  -   emin)/float(nEnergy)"
  write(ilun,format)"  le = 0.50d0 + (log10(Enint) - emin - log10(rho) )/dEner"
  write(ilun,format)""
  write(ilun,format)"  if ((le .ge. nEnergy) ) then"
  write(ilun,format)"     write(*,*)'intermaxE_s',Enint ,Ener_eos(ir,nEnergy)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ie = floor(le)"
  write(ilun,format)"  if  (ir < 1 .or. ie < 1 ) then"
  write(ilun,format)"     write(*,*) 'inter_Cs hors limite i,ir,ie = ',ir,ie,rho ,Enint, myid"
  write(ilun,format)"     ir=1.0d0"
  write(ilun,format)"     ie=1.0d0"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  dd1 = lr - float(ir)"
  write(ilun,format)"  dd2 = le - float(ie)"
  write(ilun,format)""
  write(ilun,format)"  de1 = 1.0d0 - dd1"
  write(ilun,format)"  de2 = 1.0d0 - dd2"
  write(ilun,format)""
  write(ilun,format)"  Cseos=0.d0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  Cseos = Cseos + de1*de2*Cs_eos(ir  ,ie  )"
  write(ilun,format)"  Cseos = Cseos + dd1*de2*Cs_eos(ir+1,ie  )"
  write(ilun,format)"  Cseos = Cseos + de1*dd2*Cs_eos(ir  ,ie+1)"
  write(ilun,format)"  Cseos = Cseos + dd1*dd2*Cs_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"  Cseos = Cseos /scale_v ! give Cs in code units"
  write(ilun,format)""
  write(ilun,format)"  xx =  Cs_eos(ir,ie)*Cs_eos(ir+1,ie)*Cs_eos(ir,ie+1)*Cs_eos(ir+1,ie+1) "
  write(ilun,format)""
  write(ilun,format)"  if (xx .eq. 0.0d0 ) then"
  write(ilun,format)"     write(*,*) '**************** Cs_eos ****************'"
  write(ilun,format)"     write(*,*) 'ir,ie,i =',ir,ie,i"
  write(ilun,format)"     write(*,*) rho ,Enint "
  write(ilun,format)"     write(*,*) Cs_eos(ir,ie  ), Cs_eos(ir+1,ie  ) "
  write(ilun,format)"     write(*,*) Cs_eos(ir,ie+1), Cs_eos(ir+1,ie+1)"
  write(ilun,format)"     write(*,*) Cs_eos(ir,ie+2), Cs_eos(ir-1,ie+1)"
  write(ilun,format)"     write(*,*) 0.25*(Cs_eos(ir,ie+2) + Cs_eos(ir-1,ie+1) +   Cs_eos(ir+1,ie+1) +  Cs_eos(ir,ie))"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"else"
  write(ilun,format)"  Cseos = sqrt(gamma*(gamma-1.d0)*Enint_temp/rho_temp)"
  write(ilun,format)"end if"
  write(ilun,format)"end subroutine soundspeed_eos"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"function cmp_Cv_eos(rho,Enint)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,only: mh,kb"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes Cv using"
  write(ilun,format)"  ! the eos calculated by Chabrier & Saumon, as a function"
  write(ilun,format)"  ! of density and internal energy"
  write(ilun,format)"  ! Units are supposed to be in cgs here (as in units.f90)"
  write(ilun,format)"  !--------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)   :: rho,Enint,xx"
  write(ilun,format)"  real(dp)   :: drho,dener"
  write(ilun,format)"  real(dp)   :: dd1,dd2,de1,de2"
  write(ilun,format)"  real(dp)   :: lr,le"
  write(ilun,format)"  real(dp)   :: cmp_Cv_eos"
  write(ilun,format)"  integer    :: ir,ie,i"
  write(ilun,format)""
  write(ilun,format)"  drho  = (rhomax-rhomin)/float(nRho)"
  write(ilun,format)"  lr = 0.5d0 + (log10(rho )- rhomin )/drho"
  write(ilun,format)""
  write(ilun,format)"  if (lr .ge. Nrho) then"
  write(ilun,format)"     write(*,*)'intermaxrho',rho ,rho_eos(nRho,1)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ir = floor(lr)"
  write(ilun,format)""
  write(ilun,format)"  dEner = ( Emax  -   emin)/float(nEnergy)"
  write(ilun,format)"  le = 0.5d0 + (log10(Enint) - emin - log10(rho) )/dEner"
  write(ilun,format)""
  write(ilun,format)"  if ((le .ge. nEnergy) ) then"
  write(ilun,format)"     write(*,*)'intermaxE2',Enint ,Ener_eos(ir,nEnergy)"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ie = floor(le)"
  write(ilun,format)"  if  (ir < 1 .or. ie < 1 ) then"
  write(ilun,format)"!!       write(*,*) 'inter_cv hors limite i,ir,ie = ',ir,ie,rho ,Enint"
  write(ilun,format)"     ir=1.0d0"
  write(ilun,format)"     ie=1.0d0"
  write(ilun,format)"     !      stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  dd1 = lr - float(ir)"
  write(ilun,format)"  dd2 = le - float(ie)"
  write(ilun,format)""
  write(ilun,format)"  de1 = 1.0d0 - dd1"
  write(ilun,format)"  de2 = 1.0d0 - dd2"
  write(ilun,format)""
  write(ilun,format)"  cmp_Cv_eos=0.d0"
  write(ilun,format)""
  write(ilun,format)"  cmp_Cv_eos = cmp_Cv_eos + de1*de2*Cv_eos(ir  ,ie  )"
  write(ilun,format)"  cmp_Cv_eos = cmp_Cv_eos + dd1*de2*Cv_eos(ir+1,ie  )"
  write(ilun,format)"  cmp_Cv_eos = cmp_Cv_eos + de1*dd2*Cv_eos(ir  ,ie+1)"
  write(ilun,format)"  cmp_Cv_eos = cmp_Cv_eos + dd1*dd2*Cv_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"  cmp_Cv_eos = cmp_Cv_eos"
  write(ilun,format)""
  write(ilun,format)"  xx =  Cv_eos(ir,ie)*Cv_eos(ir+1,ie)*Cv_eos(ir,ie+1)*Cv_eos(ir+1,ie+1)"
  write(ilun,format)""
  write(ilun,format)"  if (xx .eq. 0.0d0 ) then"
  write(ilun,format)"     write(*,*) '**************** Pb_eos ****************'"
  write(ilun,format)"     write(*,*) 'ir,ie,i =',ir,ie,i"
  write(ilun,format)"     write(*,*) rho ,Enint"
  write(ilun,format)"     write(*,*) Cv_eos(ir,ie  ), Cv_eos(ir+1,ie  )"
  write(ilun,format)"     write(*,*) Cv_eos(ir,ie+1), Cv_eos(ir+1,ie+1)"
  write(ilun,format)"     write(*,*) Cv_eos(ir,ie+2), Cv_eos(ir-1,ie+1)"
  write(ilun,format)"     write(*,*) 0.25*(Cv_eos(ir,ie+2) + Cv_eos(ir-1,ie+1) +   Cv_eos(ir+1,ie+1) +  Cv_eos(ir,ie))"
  write(ilun,format)"     stop"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end function cmp_Cv_eos"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"double precision function barotrop1D(rhon)"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use amr_parameters, only : n_star"
  write(ilun,format)"  use radiation_parameters, only : Tr_floor"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::inp,ll,rhon"
  write(ilun,format)"  integer :: j"
  write(ilun,format)""
  write(ilun,format)"  if(analytical_barotrop)then"
  write(ilun,format)"     barotrop1D = Tr_floor * ( 1.0d0 + (rhon/n_star)**(gamma-1.0d0) )"
  write(ilun,format)"  else"
  write(ilun,format)"     inp=rhon ! in g.cc"
  write(ilun,format)"     ll=(1.d0+(log10(inp)-rhomin_barotrop)/drho_barotrop)"
  write(ilun,format)"     j=dble(floor(ll))"
  write(ilun,format)"     barotrop1D=(ll-j)*(temp_barotrop(j+1))+(1.d0-(ll-j))*(temp_barotrop(j))"
  write(ilun,format)"     barotrop1D=10.0d0**barotrop1D     ! temperature in K"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end function barotrop1D"
  write(ilun,format)"../patch/collapse/radiation_boundary.f90"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  integer,intent(IN)::ilevel,igroup"
  write(ilun,format)"  integer::ibound,boundary_dir,idim,inbor"
  write(ilun,format)"  integer::i,ncache,ivar,igrid,ngrid,ind,ht"
  write(ilun,format)"  integer::iskip,iskip_ref,nx_loc,ix,iy,iz,igrp"
  write(ilun,format)"  integer,dimension(1:8)::ind_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp)::rosseland_ana"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::uu"
  write(ilun,format)"  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho"
  write(ilun,format)""
  write(ilun,format)"  if(.not. simple_boundary)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over boundaries"
  write(ilun,format)"  do ibound=1,nboundary"
  write(ilun,format)"     ! Compute direction of reference neighbors"
  write(ilun,format)"     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)"
  write(ilun,format)"     if(boundary_dir==1)inbor=2"
  write(ilun,format)""
  write(ilun,format)"     if(boundary_dir==2)inbor=1"
  write(ilun,format)"     if(boundary_dir==3)inbor=4"
  write(ilun,format)"     if(boundary_dir==4)inbor=3"
  write(ilun,format)"     if(boundary_dir==5)inbor=6"
  write(ilun,format)"     if(boundary_dir==6)inbor=5"
  write(ilun,format)""
  write(ilun,format)"     ! Compute index of reference cells"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)"     ! Imposed boundary"
  write(ilun,format)"     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     ncache=boundary(ibound,ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Gather neighboring reference grid"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather neighboring reference cell"
  write(ilun,format)"           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"!!            ! Zero flux boundary conditions"
  write(ilun,format)"!!            if((boundary_type(ibound)/10).ne.2)then"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Gather reference variables and  scatter to boundary region"
  write(ilun,format)"!!               do i=1,ngrid"
  write(ilun,format)"!!                  if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"!!                     uold(ind_cell(i),8+igroup)  = uold(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     unew(ind_cell(i),8+igroup)  = unew(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     unew(ind_cell(i),5)     = unew(ind_cell_ref(i),5)"
  write(ilun,format)"!!                     unew(ind_cell(i),nvar+3)= unew(ind_cell_ref(i),5)"
  write(ilun,format)"!!                     enew(ind_cell(i))       = unew(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     divu(ind_cell(i))       = divu(ind_cell_ref(i))"
  write(ilun,format)"!!                     unew(ind_cell(i),2)     = unew(ind_cell_ref(i),2)"
  write(ilun,format)"!!                  end if"
  write(ilun,format)"!!               end do"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Imposed boundary conditions"
  write(ilun,format)"!!            else"
  write(ilun,format)""
  write(ilun,format)"              ! Compute cell center in code units and rescale position from code units to user units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              call boundana(xx,uu,dx_loc,ibound,ngrid)"
  write(ilun,format)"              "
  write(ilun,format)"              ! Scatter variables"
  write(ilun,format)"              do i=1,ngrid "
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                    dd=max(uu(i,1),smallr)"
  write(ilun,format)"                    "
  write(ilun,format)"                    usquare=0.0_dp"
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)"                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total magnetic energy"
  write(ilun,format)"                    emag = 0.0_dp"
  write(ilun,format)"                    do ivar=1,3"
  write(ilun,format)"                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total non-thermal+radiative energy"
  write(ilun,format)"                    erad_loc=0.0_dp"
  write(ilun,format)"                    do igrp=1,nener"
  write(ilun,format)"                       erad_loc=erad_loc+uu(i,8+igrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    rho   = uu(i,1)"
  write(ilun,format)"                    ekin  = rho*usquare*0.5_dp"
  write(ilun,format)"                    eps   = (uu(i,5)-ekin-emag-erad_loc)"
  write(ilun,format)""
  write(ilun,format)"                    call temperature_eos(rho,eps,t2,ht)"
  write(ilun,format)"                    t2    = Tr_floor ! comment this for radiative shock"
  write(ilun,format)""
  write(ilun,format)"                    unew(ind_cell(i),nvar+3) = t2"
  write(ilun,format)"                    unew(ind_cell(i),5)      = t2"
  write(ilun,format)"                    "
  write(ilun,format)"                    uold(ind_cell(i),firstindex_er+igroup)= uu(i,firstindex_er+igroup)*scale_d*scale_v**2/(scale_E0)"
  write(ilun,format)"                    unew(ind_cell(i),firstindex_er+igroup)= uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)"                    enew(ind_cell(i)         )= uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)"                    unew(ind_cell(i),2       )= 0.0_dp"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! Compute Rosseland opacity"
  write(ilun,format)"                    t2r = cal_Teg(unew(ind_cell(i),firstindex_er+igroup)*scale_E0,igroup)"
  write(ilun,format)"                    divu(ind_cell(i))= rosseland_ana(dd*scale_d,t2,t2r,igroup)/scale_kappa"
  write(ilun,format)"                    if(divu(ind_cell(i))*dx_loc .lt. min_optical_depth) divu(ind_cell(i))=min_optical_depth/dx_loc"
  write(ilun,format)"                    "
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"!!            end if"
  write(ilun,format)"              "
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"           "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over boundaries"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering make_boundary_diffusion for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_boundary_diffusion"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"  use amr_commons,only:boundary,son,ncoarse,nbor,xg"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  integer,intent(IN)::ilevel"
  write(ilun,format)"  integer::ibound,boundary_dir,idim,inbor,igroup,ht"
  write(ilun,format)"  integer::i,ncache,ivar,igrid,ngrid,ind"
  write(ilun,format)"  integer::iskip,iskip_ref,gdim,nx_loc,ix,iy,iz,igrp,irad"
  write(ilun,format)"  integer,dimension(1:8)::ind_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp)::rosseland_ana,planck_ana"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::uu"
  write(ilun,format)"  real(dp),dimension(1:nvector)::cond,relax"
  write(ilun,format)"  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho"
  write(ilun,format)""
  write(ilun,format)"  if(.not. simple_boundary)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/zero,zero,zero/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-half)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-half)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-half)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over boundaries"
  write(ilun,format)"  do ibound=1,nboundary"
  write(ilun,format)"     ! Compute direction of reference neighbors"
  write(ilun,format)"     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)"
  write(ilun,format)"     if(boundary_dir==1)inbor=2"
  write(ilun,format)""
  write(ilun,format)"     if(boundary_dir==2)inbor=1"
  write(ilun,format)"     if(boundary_dir==3)inbor=4"
  write(ilun,format)"     if(boundary_dir==4)inbor=3"
  write(ilun,format)"     if(boundary_dir==5)inbor=6"
  write(ilun,format)"     if(boundary_dir==6)inbor=5"
  write(ilun,format)""
  write(ilun,format)"     ! Compute index of reference cells"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)"     ! Imposed boundary"
  write(ilun,format)"     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     ncache=boundary(ibound,ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Gather neighboring reference grid"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather neighboring reference cell"
  write(ilun,format)"           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"!!            ! Zero flux boundary conditions"
  write(ilun,format)"!!            if((boundary_type(ibound)/10).ne.2)then"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Gather reference variables and  scatter to boundary region"
  write(ilun,format)"!!               do i=1,ngrid"
  write(ilun,format)"!!                  if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"!! #if USE_FLD==1"
  write(ilun,format)"!!                     do igroup=1,ngrp"
  write(ilun,format)"!!                        kappaR_bicg(ind_cell(i),igroup)       = kappaR_bicg(ind_cell_ref(i),igroup)"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!                     do irad=1,nvar_trad"
  write(ilun,format)"!!                        unew    (ind_cell(i),ind_trad(irad)) = unew    (ind_cell_ref(i),ind_trad(irad))"
  write(ilun,format)"!!                        uold    (ind_cell(i),ind_trad(irad)) = uold    (ind_cell_ref(i),ind_trad(irad))"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!!                     do irad = 1,nvar_bicg"
  write(ilun,format)"!!                        if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = var_bicg(ind_cell_ref(i),irad, 2)"
  write(ilun,format)"!!                        var_bicg(ind_cell(i),irad, 5) = var_bicg(ind_cell_ref(i),irad, 5)"
  write(ilun,format)"!!                        if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = var_bicg(ind_cell_ref(i),irad, 6)"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  end if"
  write(ilun,format)"!!               end do"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Imposed boundary conditions"
  write(ilun,format)"!!            else"
  write(ilun,format)""
  write(ilun,format)"              ! Compute cell center in code units and rescale position from code units to user units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              call boundana(xx,uu,dx_loc,ibound,ngrid)"
  write(ilun,format)""
  write(ilun,format)"              ! Scatter variables"
  write(ilun,format)"              do i=1,ngrid "
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                    dd=max(uu(i,1),smallr)"
  write(ilun,format)""
  write(ilun,format)"                    usquare=zero"
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)"                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total magnetic energy"
  write(ilun,format)"                    emag = zero"
  write(ilun,format)"                    do ivar=1,3"
  write(ilun,format)"                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total non-thermal+radiative energy"
  write(ilun,format)"                    erad_loc=zero"
  write(ilun,format)"                    do igrp=1,nener"
  write(ilun,format)"                       erad_loc=erad_loc+uu(i,8+igrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    rho   = uu(i,1)"
  write(ilun,format)"                    ekin  = rho*usquare*half"
  write(ilun,format)"                    eps   = (uu(i,5)-ekin-emag-erad_loc)"
  write(ilun,format)""
  write(ilun,format)"                    call temperature_eos(rho,eps,t2,ht)"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"                    uu(i,ind_trad(1)) = t2"
  write(ilun,format)"                    uu(i,ind_trad(1)) = Tr_floor ! comment this for radiative shock"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                    ! Compute Rosseland opacity"
  write(ilun,format)"                    do igroup=1,ngrp"
  write(ilun,format)"                       t2r = cal_Teg(uu(i,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"                       kappaR_bicg(ind_cell(i),igroup)= rosseland_ana(dd*scale_d,uu(i,ind_trad(1)),t2r,igroup)/scale_kappa"
  write(ilun,format)"                       if( kappaR_bicg(ind_cell(i),igroup)*dx_loc .lt. min_optical_depth)  kappaR_bicg(ind_cell(i),igroup)=min_optical_depth/dx_loc"
  write(ilun,format)"                    enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"                    do irad=1,nvar_trad"
  write(ilun,format)"                       uold(ind_cell(i),ind_trad(irad)) = uu(i,ind_trad(irad)) / norm_trad(irad)"
  write(ilun,format)"                       unew(ind_cell(i),ind_trad(irad)) = uold(ind_cell(i),ind_trad(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                   do irad = 1,nvar_bicg"
  write(ilun,format)"                      if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = zero"
  write(ilun,format)"                      var_bicg(ind_cell(i),irad, 5) = zero"
  write(ilun,format)"                      if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = zero"
  write(ilun,format)"                   enddo"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"!!            end if"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over boundaries"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering make_boundary_diffusion for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_boundary_diffusion_tot"
  write(ilun,format)"../patch/collapse/radiation_parameters.f90"
  write(ilun,format)"module radiation_parameters"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters,only:ngrp,nvar_bicg,nvar_trad"
  write(ilun,format)""
  write(ilun,format)"  ! DT adaptatif"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::rad_flux ! Flux entrant dans une cellule"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::urad     ! Old values of Erg in NR iterations"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::frad     ! Radiative force  "
  write(ilun,format)"  integer,allocatable,dimension(:)::liste_ind"
  write(ilun,format)"  integer::nb_ind"
  write(ilun,format)"  real(dp)::Tr_floor=10.0 ! Background radiation field temperature - WARNING: it affects the pressure_fix in set_uold."
  write(ilun,format)"  integer::ntp,nfr"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: alpha_imp = 1.0d0	!0.0:explicite 0.5:CN 1.0:implicite"
  write(ilun,format)"  real(dp):: robin = 1.0d0	!0.0:Von Neumann 1.0:Dirichlet"
  write(ilun,format)""
  write(ilun,format)"  ! Multigroup"
  write(ilun,format)"  integer,parameter::Nomega=100     ! Number of points in the omega data to compute Q moment term"
  write(ilun,format)""
  write(ilun,format)"  real(dp),parameter:: aR=7.56591469318689378e-015_dp"
  write(ilun,format)"  real(dp),parameter::Tray_min=0.5d0 ! Minimum temperature in the radiative energy"
  write(ilun,format)"  real(dp),parameter:: eray_min=(aR)*Tray_min**4 ! minimum rad energy inside frequency group"
  write(ilun,format)"  real(dp),parameter:: deray_min=(4.0d0*aR)*Tray_min**3 ! minimum rad energy derivative inside frequency group"
  write(ilun,format)"  real(dp):: small_er=1.0d-30       ! minimum rad energy inside frequency group in code units"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp) :: numin=1.0d5,numax=1.0d19 ! Overall frequency boudaries"
  write(ilun,format)"  real(dp) :: frequency_upperlimit=1.0d35 ! High end frequency if 'extra_end_group = .true."
  write(ilun,format)""
  write(ilun,format)"  integer::Ninv_art4=1000                               ! Number of points in tabulated arT4 function"
  write(ilun,format)"  real(dp),dimension(:    ),allocatable::dEr_inv_art4   ! Radiative energy increment"
  write(ilun,format)"  real(dp),dimension(:,:  ),allocatable::inverse_art4_T ! array for tabulated arT4 function dT regular"
  write(ilun,format)"  real(dp),dimension(:,:,:),allocatable::inverse_art4_E ! array for tabulated arT4 function dE regular"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_min_hz ! minimum freq of given group in Hz"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_max_hz ! maximum freq of given group in Hz"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_min_ev ! minimum freq of given group in eV"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_max_ev ! maximum freq of given group in eV"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp),dimension(0:Nomega):: f_array,w1_array,dw1_array,w2_array,dw2_array ! Arrays of omega terms for Q computation"
  write(ilun,format)""
  write(ilun,format)"  logical :: freqs_in_Hz=.true.      ! Frequency units in Hz if true; if not eV"
  write(ilun,format)"  logical :: read_groups=.false.     ! Read group boundaries from file if true"
  write(ilun,format)"  logical :: split_groups_log=.true. ! Automatic splitting of group in log if true; if not use regular splitting"
  write(ilun,format)"  logical :: extra_end_group=.false. ! The last group holds frequencies numax -> frequency_upperlimit if true"
  write(ilun,format)"  logical :: grey_rad_transfer=.true.! Default: grey radiation transfer"
  write(ilun,format)"  logical :: external_radiation_field=.false. ! Default: No external radiation background (@ Tr_floor)"
  write(ilun,format)"  logical :: stellar_photon=.false.  ! Stellar photons are treated as a separate group (igrp=1). No emission for this group (radiation_source=0)"
  write(ilun,format)""
  write(ilun,format)"  ! Opacities"
  write(ilun,format)"  character(len=12) :: opacity_type = 'grey'  ! 'grey' or 'multigroup'"
  write(ilun,format)""
  write(ilun,format)"  ! Radiation solver parameters"
  write(ilun,format)"  real(dp)::epsilon_diff=1d-6                        ! CG iteration break criteria"
  write(ilun,format)"  character(LEN=10)::fld_limiter='nolim'             ! Flux limiter (nolim, levermore or minerbo)"
  write(ilun,format)"  integer::i_fld_limiter"
  write(ilun,format)"  integer,parameter::i_fld_limiter_nolim=0"
  write(ilun,format)"  integer,parameter::i_fld_limiter_minerbo=1"
  write(ilun,format)"  integer,parameter::i_fld_limiter_levermore=2"
  write(ilun,format)"  real(dp)   ::dt_imp                                    ! Implicit timestep"
  write(ilun,format)"  integer :: niter=0                                 ! Total number of iteration"
  write(ilun,format)"  real(dp),dimension(1:10)::dtdiff_params=1d10       ! Conduction time step behaviour"
  write(ilun,format)"  real(dp),dimension(1:10)::rosseland_params=1.0     ! Rosseland opacity coefficient's parameters"
  write(ilun,format)"  real(dp),dimension(1:10)::planck_params=1.0        ! Planck opacity coefficient's parameters"
  write(ilun,format)"  real(dp)::mu_gas=2.31d0                            ! For Saumon Chabrier EOS"
  write(ilun,format)"  real(dp)::min_optical_depth=1.d-6        ! set the minimum optical depth in the cell (it may accelerate convergence in optically thin regions)"
  write(ilun,format)""
  write(ilun,format)"  ! Variables needed for BICG scheme"
  write(ilun,format)"  real(dp),dimension(:,:,:,:),allocatable :: coeff_glob_left,coeff_glob_right"
  write(ilun,format)"  real(dp),dimension(:,:,:  ),allocatable :: var_bicg,precond_bicg"
  write(ilun,format)"  real(dp),dimension(:,:,:  ),allocatable :: mat_residual_glob"
  write(ilun,format)"  real(dp),dimension(:,:    ),allocatable :: residual_glob"
  write(ilun,format)"  real(dp),dimension(:,:    ),allocatable :: kappaR_bicg"
  write(ilun,format)"  logical::block_diagonal_precond_bicg ! if .false. only diagonal, if .true. block diagonal"
  write(ilun,format)"  integer :: i_rho,i_beta,i_y,i_pAp,i_s"
  write(ilun,format)"  integer , dimension(1:nvar_bicg) :: ind_bicg"
  write(ilun,format)"  real(dp), dimension(1:nvar_bicg) :: norm_bicg"
  write(ilun,format)"  integer , dimension(1:nvar_trad) :: ind_trad"
  write(ilun,format)"  real(dp), dimension(1:nvar_trad) :: norm_trad"
  write(ilun,format)"  logical , dimension(1:nvar_trad) :: is_radiative_energy"
  write(ilun,format)""
  write(ilun,format)"  integer                                   :: irad_trans_model        !< Integer designating radiative transfer model: 0 = P1, 1 = M1"
  write(ilun,format)"  integer, parameter                        :: irad_trans_model_p1 = 0 !< P1 radiative transfer model identifier"
  write(ilun,format)"  integer, parameter                        :: irad_trans_model_m1 = 1 !< M1 radiative transfer model identifier"
  write(ilun,format)"  integer                                   :: n_points                !< Number of points in the tabulated eigenvalues curve"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: valp                    !< Array to hold the tabulated eigenvalues as a function of \f \theta\f  and \f \epsilon\f "
  write(ilun,format)"  real(dp)                                  :: valp_min=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"  logical::store_matrix=.true."
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1 && NGRP == 1"
  write(ilun,format)"  logical, parameter :: bicg_to_cg = .true."
  write(ilun,format)"#else"
  write(ilun,format)"  logical, parameter :: bicg_to_cg = .false."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end module radiation_parameters"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Module MOD_OPACITIES:"
  write(ilun,format)"!"
  write(ilun,format)"!>  Module for opacities"
  write(ilun,format)"!<"
  write(ilun,format)"module mod_opacities"
  write(ilun,format)"  use amr_parameters, only : dp"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_p      !< Regular mesh of Planck opacities"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_r      !< Regular mesh of Rosseland opacities"
  write(ilun,format)"  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_p     !< Rosseland opacities from Dust + Gas"
  write(ilun,format)"  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_r     !< Rosseland opacities from Dust + Gas"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: logt_dustgas        !< Temperature of points for Dust+Gas data"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: logd_dustgas        !< Density of points for Dust+Gas data"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: x_opmesh            !< X (density) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: y_opmesh            !< Y (temperature) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: z_opmesh            !< Z (rad temperature) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: numin_dustgas       !< Minimum freq. in Dust+Gas opacities"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: numax_dustgas       !< Maximum freq. in Dust+Gas opacities"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: extrapol_min        !< Extrapolation power for low frequencies"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: extrapol_max        !< Extrapolation power for high frequencies"
  write(ilun,format)"  integer , dimension(:      ), allocatable :: nfreq_dustgas       !< Number of freq. in Dust+Gas opacities"
  write(ilun,format)"  integer                                   :: nx_opmesh           !< Number of X points in opacity mesh"
  write(ilun,format)"  integer                                   :: ny_opmesh           !< Number of Y points in opacity mesh"
  write(ilun,format)"  integer                                   :: nz_opmesh           !< Number of Z points in opacity mesh"
  write(ilun,format)"  integer                                   :: npoints             !< Number of points in freq. for Dust+Gas opacities"
  write(ilun,format)"  real(dp)                                  :: tmin_op             !< "
  write(ilun,format)"  real(dp)                                  :: dx_opmesh           !< dx in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: dy_opmesh           !< dy in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: dz_opmesh           !< dy in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: opacity_dtemp"
  write(ilun,format)"  real(dp), parameter                       :: t_grain_sublim = 1.5e+03_dp !< Grain sublimation temperature"
  write(ilun,format)"end module mod_opacities"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Subroutine INIT_OPACITIES_DUST_AND_GAS:"
  write(ilun,format)"!"
  write(ilun,format)"!> Read opacities for dust from Semenov+Draine and gas from Franck."
  write(ilun,format)"!!    - The arbitrary points in Rho and T are read."
  write(ilun,format)"!!    - The Planck and Rosseland means are computed for each point for each group."
  write(ilun,format)"!!    - A Delaunay triangulation is computed from the points."
  write(ilun,format)"!!    - Each triangle defines a plane in 3D."
  write(ilun,format)"!!    - Then a finer but regular mesh in (Rho,T) is overlayed onto the triangulation."
  write(ilun,format)"!!    - This gives a regular mesh of Planck and Rosseland means to perform bicubic interpolations."
  write(ilun,format)"!<"
  write(ilun,format)"subroutine init_opacities"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use amr_commons, only : myid,nrestart"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer                                 :: i,igroup,ipoint,j,it,nnumax,k,l,kw,kernel_size,istep"
  write(ilun,format)"  integer                                 :: inu_min1,inu_max1,inu_min2,inu_max2,nparts,iprog,itrad"
  write(ilun,format)"  integer                                 :: datasize,dataread,percentage,nneighbours,in,ii,jj,kk,np"
  write(ilun,format)"  integer                                 :: iter,itermax,ntot,nmin,maxneighbours,nn,n,npasses,ntrad"
  write(ilun,format)"  logical                                 :: enough_points_found,hole_filled"
  write(ilun,format)"  real(dp), dimension(:    ), allocatable :: opnu,opknu"
  write(ilun,format)"  real(dp), dimension(:,:,:), allocatable :: bin_count"
  write(ilun,format)"  real(dp)                                :: integral1,integral2,integral3,integral4,integral5,integral6"
  write(ilun,format)"  real(dp)                                :: dist,distmin,temp,x,y,xa,ya,xx,yy,dtrad"
  write(ilun,format)"  real(dp)                                :: dmax_opmesh,dmin_opmesh,tmax_opmesh,tmin_opmesh,trmax_opmesh,trmin_opmesh"
  write(ilun,format)"  real(dp)                                :: nu1,nu2,op1,op2,m,slope,dnu,kappa_min,grad1,grad2,minmod"
  write(ilun,format)"  character (len=200)                     :: opfilename,fname"
  write(ilun,format)"  logical , dimension(:,:,:), allocatable :: i_am_a_hole"
  write(ilun,format)""
  write(ilun,format)"  if(opacity_type == 'multigroup')then"
  write(ilun,format)""
  write(ilun,format)"     if(nrestart .eq. 0)then"
  write(ilun,format)"        opfilename = 'dust_gas_opacity_table.bin'"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           write(*,*)"
  write(ilun,format)"           write(*,*) '############# MULTIGROUP DUST AND GAS OPACITIES ##############'"
  write(ilun,format)"           write(*,*) 'Reading opacity table: '//trim(opfilename)"
  write(ilun,format)"           write(*,*) '=============================================================='"
  write(ilun,format)"           write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'"
  write(ilun,format)"           write(*,*) 'COMPUTING Planck and Rosseland mean opacities for:'"
  write(ilun,format)"           write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'"
  write(ilun,format)"           write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'"
  write(ilun,format)"           write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'"
  write(ilun,format)"           write(*,*) '=============================================================='"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        !####### Set variables #######"
  write(ilun,format)"        nx_opmesh      = 100"
  write(ilun,format)"        ny_opmesh      = 100"
  write(ilun,format)"        nz_opmesh      = 100"
  write(ilun,format)"        dmin_opmesh    = -24.00_dp"
  write(ilun,format)"        dmax_opmesh    =   6.00_dp"
  write(ilun,format)"        tmin_opmesh    =   0.00_dp"
  write(ilun,format)"        tmax_opmesh    =   8.00_dp"
  write(ilun,format)"        trmin_opmesh   =   0.00_dp"
  write(ilun,format)"        trmax_opmesh   =   8.00_dp"
  write(ilun,format)"        nparts         = 10"
  write(ilun,format)"        ntrad          = 150"
  write(ilun,format)"        kappa_min      = 1.0e-50_dp"
  write(ilun,format)"        datasize       = 31637055"
  write(ilun,format)"        !#############################"
  write(ilun,format)""
  write(ilun,format)"        dtrad = (trmax_opmesh-trmin_opmesh)/real(ntrad-1,dp)"
  write(ilun,format)""
  write(ilun,format)"        open(78,file=opfilename,form='unformatted')"
  write(ilun,format)"        read(78) npoints,nnumax"
  write(ilun,format)""
  write(ilun,format)"        allocate(opnu(nnumax),opknu(nnumax))"
  write(ilun,format)"        allocate(logt_dustgas(npoints),logd_dustgas(npoints))"
  write(ilun,format)"        allocate(numin_dustgas(npoints),numax_dustgas(npoints),nfreq_dustgas(npoints))"
  write(ilun,format)"        allocate(extrapol_min(npoints),extrapol_max(npoints))"
  write(ilun,format)"        allocate(kappa_dustgas_p(ngrp,npoints,ntrad),kappa_dustgas_r(ngrp,npoints,ntrad))"
  write(ilun,format)""
  write(ilun,format)"        istep = 1"
  write(ilun,format)"        iprog = 0"
  write(ilun,format)"        dataread = 0"
  write(ilun,format)""
  write(ilun,format)"        do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"           percentage = nint(real(dataread)*100.0/real(datasize))"
  write(ilun,format)""
  write(ilun,format)"           if((myid==1) .and. (percentage .ge. iprog*istep))then"
  write(ilun,format)"              write(*,'(i3,a)') percentage,'% complete'"
  write(ilun,format)"              iprog = iprog + 1"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           read(78) logd_dustgas(ipoint),logt_dustgas(ipoint)"
  write(ilun,format)"           read(78) nfreq_dustgas(ipoint),numin_dustgas(ipoint),numax_dustgas(ipoint)"
  write(ilun,format)"           read(78) extrapol_min(ipoint),extrapol_max(ipoint)"
  write(ilun,format)"           read(78) opnu (1:nfreq_dustgas(ipoint))"
  write(ilun,format)"           read(78) opknu(1:nfreq_dustgas(ipoint))"
  write(ilun,format)""
  write(ilun,format)"           dataread = dataread + nfreq_dustgas(ipoint)"
  write(ilun,format)""
  write(ilun,format)"           ! Begin loop over Trad"
  write(ilun,format)"           do itrad = 1,ntrad"
  write(ilun,format)""
  write(ilun,format)"              temp = 10.0_dp**(real(itrad-1,dp)*dtrad + trmin_opmesh)"
  write(ilun,format)""
  write(ilun,format)"              ! find group boundaries"
  write(ilun,format)"              inu_min1 = 0 ; inu_max1 = 0"
  write(ilun,format)"              inu_min2 = 0 ; inu_max2 = 0"
  write(ilun,format)""
  write(ilun,format)"              do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                 if(nu_min_hz(igroup) .lt. opnu(1))then"
  write(ilun,format)"                    inu_min1 = 1 ; inu_min2 = 1"
  write(ilun,format)"                 elseif(nu_min_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then"
  write(ilun,format)"                    inu_min1 = nfreq_dustgas(ipoint) ; inu_min2 = nfreq_dustgas(ipoint)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i = 1,nfreq_dustgas(ipoint)-1"
  write(ilun,format)"                       if((nu_min_hz(igroup) .ge. opnu(i)).and.(nu_min_hz(igroup) .lt. opnu(i+1)))then"
  write(ilun,format)"                          inu_min1 = i ; inu_min2 = i+1"
  write(ilun,format)"                          exit"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 if(nu_max_hz(igroup) .lt. opnu(1))then"
  write(ilun,format)"                    inu_max1 = 1 ; inu_max2 = 1"
  write(ilun,format)"                 elseif(nu_max_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then"
  write(ilun,format)"                    inu_max1 = nfreq_dustgas(ipoint) ; inu_max2 = nfreq_dustgas(ipoint)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i = 1,nfreq_dustgas(ipoint)-1"
  write(ilun,format)"                       if((nu_max_hz(igroup) .ge. opnu(i)).and.(nu_max_hz(igroup) .lt. opnu(i+1)))then"
  write(ilun,format)"                          inu_max1 = i ; inu_max2 = i+1"
  write(ilun,format)"                          exit"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! compute Planck and Rosseland mean opacities"
  write(ilun,format)""
  write(ilun,format)"                 integral1 = 0.0_dp"
  write(ilun,format)"                 integral2 = 0.0_dp"
  write(ilun,format)"                 integral3 = 0.0_dp"
  write(ilun,format)"                 integral4 = 0.0_dp"
  write(ilun,format)"                 integral5 = 0.0_dp"
  write(ilun,format)"                 integral6 = 0.0_dp"
  write(ilun,format)""
  write(ilun,format)"                 ! If first frequency is outside opacity frequency range"
  write(ilun,format)"                 if(inu_min1 .eq. inu_min2)then"
  write(ilun,format)"                    ! Case where both frequencies are outside table on the same side"
  write(ilun,format)"                    if(inu_min1 .eq. inu_max1)then"
  write(ilun,format)"                       ! Select which slope to use"
  write(ilun,format)"                       if(inu_min1 .eq. 1)then"
  write(ilun,format)"                          slope = extrapol_min(ipoint)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          slope = extrapol_max(ipoint)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       ! Split interval into 10 parts"
  write(ilun,format)"                       dnu = (log10(nu_max_hz(igroup)) - log10(nu_min_hz(igroup)))/real(nparts,dp)"
  write(ilun,format)"                       do i = 1,nparts"
  write(ilun,format)"                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op1 = max(op1,kappa_min)"
  write(ilun,format)"                          op2 = max(op2,kappa_min)"
  write(ilun,format)"                          call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                               integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    else"
  write(ilun,format)"                       !Case where only numin is outside of range"
  write(ilun,format)"                       ! Select which slope to use"
  write(ilun,format)"                       if(inu_min1 .eq. 1)then"
  write(ilun,format)"                          slope = extrapol_min(ipoint)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          slope = extrapol_max(ipoint)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       ! Split interval into 10 parts"
  write(ilun,format)"                       dnu = (log10(opnu(inu_min1))-log10(nu_min_hz(igroup)))/real(nparts,dp)"
  write(ilun,format)"                       do i = 1,nparts"
  write(ilun,format)"                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op1 = max(op1,kappa_min)"
  write(ilun,format)"                          op2 = max(op2,kappa_min)"
  write(ilun,format)"                          call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                               integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! If last frequency is outside opacity frequency range"
  write(ilun,format)"                 if((inu_max1 .eq. nfreq_dustgas(ipoint)) .and. (inu_max1 .eq. inu_max1))then"
  write(ilun,format)"                    !Case where numax is outside of range"
  write(ilun,format)"                    slope = extrapol_max(ipoint)"
  write(ilun,format)"                    ! Split interval into 10 parts"
  write(ilun,format)"                    dnu = (log10(nu_max_hz(igroup))-log10(opnu(inu_max1)))/real(nparts,dp)"
  write(ilun,format)"                    do i = 1,nparts"
  write(ilun,format)"                       nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(opnu(inu_max1)))"
  write(ilun,format)"                       nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(opnu(inu_max1)))"
  write(ilun,format)"                       op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))"
  write(ilun,format)"                       op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))"
  write(ilun,format)"                       op1 = max(op1,kappa_min)"
  write(ilun,format)"                       op2 = max(op2,kappa_min)"
  write(ilun,format)"                       call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                            integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! First part of the curve between numin and inumin"
  write(ilun,format)"                 if(inu_min1 .ne. inu_min2)then"
  write(ilun,format)"                    nu1 = opnu (inu_min1)"
  write(ilun,format)"                    nu2 = opnu (inu_min2)"
  write(ilun,format)"                    m = ( opknu(inu_min2) - opknu(inu_min1) ) / (nu2 - nu1)"
  write(ilun,format)"                    op1 = m * (nu_min_hz(igroup)-nu1) + opknu(inu_min1)"
  write(ilun,format)"                    op2 = opknu(inu_min2)"
  write(ilun,format)"                    nu1 = nu_min_hz(igroup)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Last part of the curve between inumax and numax"
  write(ilun,format)"                 if(inu_max1 .ne. inu_max2)then"
  write(ilun,format)"                    nu1 = opnu (inu_max1)"
  write(ilun,format)"                    nu2 = opnu (inu_max2)"
  write(ilun,format)"                    m = ( opknu(inu_max2) - opknu(inu_max1) ) / (nu2 - nu1)"
  write(ilun,format)"                    op1 = opknu(inu_max1)"
  write(ilun,format)"                    op2 = m * (nu_max_hz(igroup)-nu1) + opknu(inu_max1)"
  write(ilun,format)"                    nu2 = nu_max_hz(igroup)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Middle part between inumin and inumax"
  write(ilun,format)"                 do i = inu_min2,inu_max1-1"
  write(ilun,format)"                    nu1 = opnu (i  )"
  write(ilun,format)"                    nu2 = opnu (i+1)"
  write(ilun,format)"                    op1 = opknu(i  )"
  write(ilun,format)"                    op2 = opknu(i+1)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if(abs(integral1) < 1.0e-50_dp)then"
  write(ilun,format)"                    kappa_dustgas_p(igroup,ipoint,itrad) = integral5 / integral6"
  write(ilun,format)"                 else"
  write(ilun,format)"                    kappa_dustgas_p(igroup,ipoint,itrad) = integral1 / integral2"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(abs(integral3) < 1.0e-50_dp)then"
  write(ilun,format)"                    kappa_dustgas_r(igroup,ipoint,itrad) = integral5 / integral6"
  write(ilun,format)"                 else"
  write(ilun,format)"                    kappa_dustgas_r(igroup,ipoint,itrad) = integral3 / integral4"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 !         if(logt_dustgas(ipoint) > 5.0)then"
  write(ilun,format)"                 !            write(*,*) ipoint,igroup,integral1,integral2,integral3,integral4,&"
  write(ilun,format)"                 !                       kappa_dustgas_p(igroup,ipoint),kappa_dustgas_r(igroup,ipoint)"
  write(ilun,format)"                 !         endif"
  write(ilun,format)""
  write(ilun,format)"              enddo ! end do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"           enddo ! end do itrad = 1,ntrad"
  write(ilun,format)""
  write(ilun,format)"        enddo ! end do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"        close(78)"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           write(*,*) 'Number of points:',npoints"
  write(ilun,format)"           write(*,*) 'Rhomin,Rhomax:',minval(logd_dustgas),maxval(logd_dustgas)"
  write(ilun,format)"           write(*,*) 'Tmin,Tmax:',minval(logt_dustgas),maxval(logt_dustgas)"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Create a mesh of (rho,T) points:"
  write(ilun,format)"        if(myid==1) write(*,*) 'Computing regular mesh of opacities'"
  write(ilun,format)""
  write(ilun,format)"        allocate(bin_count(nx_opmesh,ny_opmesh,nz_opmesh),i_am_a_hole(nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)"        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)"        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"        dx_opmesh = (dmax_opmesh-dmin_opmesh)/real(nx_opmesh-1,dp)"
  write(ilun,format)"        dy_opmesh = (tmax_opmesh-tmin_opmesh)/real(ny_opmesh-1,dp)"
  write(ilun,format)"        dz_opmesh = (trmax_opmesh-trmin_opmesh)/real(nz_opmesh-1,dp)     "
  write(ilun,format)""
  write(ilun,format)"        x_opmesh(1) = dmin_opmesh"
  write(ilun,format)"        y_opmesh(1) = tmin_opmesh"
  write(ilun,format)"        z_opmesh(1) = trmin_opmesh"
  write(ilun,format)""
  write(ilun,format)"        do i = 2,nx_opmesh"
  write(ilun,format)"           x_opmesh(i) = x_opmesh(i-1) + dx_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)"        do j = 2,ny_opmesh"
  write(ilun,format)"           y_opmesh(j) = y_opmesh(j-1) + dy_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)"        do k = 2,nz_opmesh"
  write(ilun,format)"           z_opmesh(k) = z_opmesh(k-1) + dz_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        bin_count = 0.0_dp"
  write(ilun,format)"        kappa_opmesh_p = 0.0_dp"
  write(ilun,format)"        kappa_opmesh_r = 0.0_dp"
  write(ilun,format)"        i_am_a_hole = .true."
  write(ilun,format)""
  write(ilun,format)"        do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"           i = floor((logd_dustgas(ipoint)-dmin_opmesh)/dx_opmesh - 0.5_dp) + 2"
  write(ilun,format)"           j = floor((logt_dustgas(ipoint)-tmin_opmesh)/dy_opmesh - 0.5_dp) + 2"
  write(ilun,format)""
  write(ilun,format)"           ! now search along Trad direction"
  write(ilun,format)"           do itrad = 1,ntrad"
  write(ilun,format)"              temp = real(itrad-1,dp)*dtrad + trmin_opmesh"
  write(ilun,format)""
  write(ilun,format)"              k = floor((temp-tmin_opmesh)/dz_opmesh - 0.5_dp) + 2"
  write(ilun,format)""
  write(ilun,format)"              do igroup = 1,ngrp"
  write(ilun,format)"                 kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) + kappa_dustgas_p(igroup,ipoint,itrad)"
  write(ilun,format)"                 kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) + kappa_dustgas_r(igroup,ipoint,itrad)"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"              bin_count(i,j,k) = bin_count(i,j,k) + 1.0_dp"
  write(ilun,format)"              i_am_a_hole(i,j,k) = .false."
  write(ilun,format)""
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        do k = 1,nz_opmesh"
  write(ilun,format)"           do j = 1,ny_opmesh"
  write(ilun,format)"              do i = 1,nx_opmesh"
  write(ilun,format)"                 if(i_am_a_hole(i,j,k))then"
  write(ilun,format)"                    do igroup = 1,ngrp"
  write(ilun,format)"                       kappa_opmesh_p(igroup,i,j,k) = 1.0e-30_dp"
  write(ilun,format)"                       kappa_opmesh_r(igroup,i,j,k) = 1.0e-30_dp"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do igroup = 1,ngrp"
  write(ilun,format)"                       kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) / bin_count(i,j,k)"
  write(ilun,format)"                       kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) / bin_count(i,j,k)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)"              enddo"
  write(ilun,format)"           enddo"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        ! Convert to log"
  write(ilun,format)"        kappa_opmesh_p = log10(kappa_opmesh_p)"
  write(ilun,format)"        kappa_opmesh_r = log10(kappa_opmesh_r)"
  write(ilun,format)""
  write(ilun,format)"        ! Now fill holes in table"
  write(ilun,format)"        if(myid==1)write(*,*) 'Filling holes in table...'"
  write(ilun,format)""
  write(ilun,format)"        ! First find holes which are surrounded by many points, and then go to bigger ang bigger holes"
  write(ilun,format)""
  write(ilun,format)"        npasses = 10 ! number of times to perform filling process"
  write(ilun,format)""
  write(ilun,format)"        do n = 1,npasses"
  write(ilun,format)""
  write(ilun,format)"           nneighbours = 26"
  write(ilun,format)"           maxneighbours = 0"
  write(ilun,format)"           itermax = 8"
  write(ilun,format)"           do in = nneighbours,0,-1"
  write(ilun,format)""
  write(ilun,format)"              do k = 1,nz_opmesh"
  write(ilun,format)"                 do j = 1,ny_opmesh"
  write(ilun,format)"                    do i = 1,nx_opmesh"
  write(ilun,format)"                       if(i_am_a_hole(i,j,k))then"
  write(ilun,format)""
  write(ilun,format)"                          ! Find number of neighbours"
  write(ilun,format)"                          nn = 0"
  write(ilun,format)"                          do ii = max(i-1,1),min(i+1,nx_opmesh)"
  write(ilun,format)"                             do jj = max(j-1,1),min(j+1,ny_opmesh)"
  write(ilun,format)"                                do kk = max(k-1,1),min(k+1,nz_opmesh)"
  write(ilun,format)"                                   if(.not.i_am_a_hole(ii,jj,kk))then"
  write(ilun,format)"                                      nn = nn + 1"
  write(ilun,format)"                                   endif"
  write(ilun,format)"                                enddo"
  write(ilun,format)"                             enddo"
  write(ilun,format)"                          enddo"
  write(ilun,format)""
  write(ilun,format)"                          if(nn == in)then"
  write(ilun,format)""
  write(ilun,format)"                             hole_filled = .false."
  write(ilun,format)""
  write(ilun,format)"                             do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                                do iter = 1,itermax"
  write(ilun,format)""
  write(ilun,format)"                                   np = 0"
  write(ilun,format)"                                   xx = 0.0_dp"
  write(ilun,format)"                                   yy = 0.0_dp"
  write(ilun,format)"                                   ntot = (1 + 2*iter)**3 - 1"
  write(ilun,format)"                                   nmin = int(2.0_dp*sqrt(real(ntot,dp)))   ! ntot / 2 + 1"
  write(ilun,format)"                                   enough_points_found = .false."
  write(ilun,format)""
  write(ilun,format)"                                   do ii = max(i-iter,1),min(i+iter,nx_opmesh)"
  write(ilun,format)"                                      do jj = max(j-iter,1),min(j+iter,ny_opmesh)"
  write(ilun,format)"                                         do kk = max(k-iter,1),min(k+iter,nz_opmesh)"
  write(ilun,format)""
  write(ilun,format)"                                            if(.not.i_am_a_hole(ii,jj,kk))then"
  write(ilun,format)"                                               xx = xx + kappa_opmesh_p(igroup,ii,jj,kk)"
  write(ilun,format)"                                               yy = yy + kappa_opmesh_r(igroup,ii,jj,kk)"
  write(ilun,format)"                                               np = np + 1"
  write(ilun,format)"                                            endif"
  write(ilun,format)""
  write(ilun,format)"                                         enddo"
  write(ilun,format)"                                      enddo"
  write(ilun,format)"                                   enddo"
  write(ilun,format)""
  write(ilun,format)"                                   if(np .ge. nmin)then"
  write(ilun,format)"                                      enough_points_found = .true."
  write(ilun,format)"                                      exit"
  write(ilun,format)"                                   endif"
  write(ilun,format)""
  write(ilun,format)"                                enddo"
  write(ilun,format)""
  write(ilun,format)"                                if(enough_points_found)then"
  write(ilun,format)"                                   kappa_opmesh_p(igroup,i,j,k) = xx / real(np,dp)"
  write(ilun,format)"                                   kappa_opmesh_r(igroup,i,j,k) = yy / real(np,dp)"
  write(ilun,format)"                                   hole_filled = .true."
  write(ilun,format)"                                endif"
  write(ilun,format)""
  write(ilun,format)"                             enddo"
  write(ilun,format)""
  write(ilun,format)"                             if(hole_filled) i_am_a_hole(i,j,k) = .false."
  write(ilun,format)""
  write(ilun,format)"                          endif"
  write(ilun,format)""
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    enddo ! end do i = 1,nx_opmesh"
  write(ilun,format)"                 enddo ! end do j = 1,ny_opmesh"
  write(ilun,format)"              enddo ! end do k = 1,nz_opmesh"
  write(ilun,format)""
  write(ilun,format)"           enddo ! end do in = nneighbours,0,-1"
  write(ilun,format)""
  write(ilun,format)"        enddo ! end do n = 1,npasses"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)write(*,*) 'Done'"
  write(ilun,format)""
  write(ilun,format)"        ! Free memory"
  write(ilun,format)"        deallocate(opnu,opknu)"
  write(ilun,format)"        deallocate(logt_dustgas,logd_dustgas)"
  write(ilun,format)"        deallocate(numin_dustgas,numax_dustgas,nfreq_dustgas)"
  write(ilun,format)"        deallocate(extrapol_min,extrapol_max)"
  write(ilun,format)"        deallocate(kappa_dustgas_p,kappa_dustgas_r)"
  write(ilun,format)"        deallocate(bin_count,i_am_a_hole)"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           open (79,file='multigroup_opacity.bin',form='unformatted')"
  write(ilun,format)"           write (79) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"           write (79) x_opmesh"
  write(ilun,format)"           write (79) y_opmesh"
  write(ilun,format)"           write (79) z_opmesh"
  write(ilun,format)"           write (79) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"           write (79) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"           close(79)"
  write(ilun,format)"        end if"
  write(ilun,format)"     else"
  write(ilun,format)"        if(myid==1)write(*,*),'Reading opacity table from previous run'"
  write(ilun,format)""
  write(ilun,format)"        open (80,file='multigroup_opacity.bin',form='unformatted')"
  write(ilun,format)"        read (80) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)"        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"        read (80) x_opmesh"
  write(ilun,format)"        read (80) y_opmesh"
  write(ilun,format)"        read (80) z_opmesh"
  write(ilun,format)"        read (80) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"        read (80) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"        close(80)"
  write(ilun,format)""
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)""
  write(ilun,format)"     if(ngrp .gt. 1 .and. myid==1)then"
  write(ilun,format)"        write(*,*) "
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"        write(*,*) 'WARNING: using grey opacities with NGROUP>1!'"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     opfilename = 'vaytet_grey_opacities3D.bin'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        write(*,*)"
  write(ilun,format)"        write(*,*) '################ GREY DUST AND GAS OPACITIES #################'"
  write(ilun,format)"        write(*,*) 'Reading opacity table: '//trim(opfilename)"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"        write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'"
  write(ilun,format)"        write(*,*) 'READING Planck and Rosseland mean opacities for:'"
  write(ilun,format)"        write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'"
  write(ilun,format)"        write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'"
  write(ilun,format)"        write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     open (78,file=trim(opfilename),form='unformatted')"
  write(ilun,format)"     read (78) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"     allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)"     allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"     read (78) x_opmesh"
  write(ilun,format)"     read (78) y_opmesh"
  write(ilun,format)"     read (78) z_opmesh"
  write(ilun,format)"     read (78) kappa_opmesh_p(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"     read (78) kappa_opmesh_r(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"     close(78)"
  write(ilun,format)""
  write(ilun,format)"     if(ngrp .gt. 1)then"
  write(ilun,format)"        do k = 1,nz_opmesh"
  write(ilun,format)"           do j = 1,ny_opmesh"
  write(ilun,format)"              do i = 1,nx_opmesh"
  write(ilun,format)"                 do igroup=2,ngrp"
  write(ilun,format)"                    kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(1,i,j,k)"
  write(ilun,format)"                    kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(1,i,j,k)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*) 'INIT_OPACITIES complete'"
  write(ilun,format)"     write(*,*) '##############################################################'"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine init_opacities"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Function PLANCK_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> Compute Planck average opacity."
  write(ilun,format)"!<"
  write(ilun,format)"function planck_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use pm_commons,only:Teff_sink"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer, intent(in) :: igroup"
  write(ilun,format)"  real(dp),intent(in) :: dens,Tp,Tr"
  write(ilun,format)"  "
  write(ilun,format)"  integer             :: ival,jval,kval"
  write(ilun,format)"  real(dp)            :: x,y,z,dx,dy,dz"
  write(ilun,format)"  real(dp)            :: x0,x1,y0,y1,z0,z1"
  write(ilun,format)"  real(dp)            :: c00,c01,c10,c11,c0,c1"
  write(ilun,format)"  real(dp)            :: planck_ana"
  write(ilun,format)"  "
  write(ilun,format)"  ! compute dust and gas opacities"
  write(ilun,format)"  x = log10(dens)"
  write(ilun,format)"  y = log10(Tp)"
  write(ilun,format)"  z = log10(Tr)"
  write(ilun,format)"  if(stellar_photon)then"
  write(ilun,format)"     if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) "
  write(ilun,format)"  end if"
  write(ilun,format)"    "
  write(ilun,format)"  ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1"
  write(ilun,format)"  jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1"
  write(ilun,format)"  kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1"
  write(ilun,format)"  "
  write(ilun,format)"  ! Perform tri-linear interpolation"
  write(ilun,format)"  "
  write(ilun,format)"  ! Compute coordinate deltas"
  write(ilun,format)"  x0 = x_opmesh(ival  )"
  write(ilun,format)"  x1 = x_opmesh(ival+1)"
  write(ilun,format)"  y0 = y_opmesh(jval  )"
  write(ilun,format)"  y1 = y_opmesh(jval+1)"
  write(ilun,format)"  z0 = z_opmesh(kval  )"
  write(ilun,format)"  z1 = z_opmesh(kval+1)"
  write(ilun,format)"  "
  write(ilun,format)"  dx = (x-x0)/(x1-x0)"
  write(ilun,format)"  dy = (y-y0)/(y1-y0)"
  write(ilun,format)"  dz = (z-z0)/(z1-z0)"
  write(ilun,format)"  "
  write(ilun,format)"  ! First linear interpolation along x"
  write(ilun,format)"  c00 = kappa_opmesh_p(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval  )*dx"
  write(ilun,format)"  c10 = kappa_opmesh_p(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval  )*dx"
  write(ilun,format)"  c01 = kappa_opmesh_p(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval+1)*dx"
  write(ilun,format)"  c11 = kappa_opmesh_p(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval+1)*dx"
  write(ilun,format)"  "
  write(ilun,format)"  ! Second linear interpolation along y"
  write(ilun,format)"  c0 = c00*(1.0_dp-dy) + c10*dy"
  write(ilun,format)"  c1 = c01*(1.0_dp-dy) + c11*dy"
  write(ilun,format)"  "
  write(ilun,format)"  ! Third linear interpolation along z"
  write(ilun,format)"  planck_ana = c0*(1.0_dp-dz) + c1*dz"
  write(ilun,format)"  "
  write(ilun,format)"  planck_ana = dens*10.0_dp**(planck_ana)"
  write(ilun,format)""
  write(ilun,format)"end function planck_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Function ROSSELAND_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> Compute Rosseland mean opacity."
  write(ilun,format)"!<"
  write(ilun,format)"function rosseland_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use pm_commons,only:Teff_sink"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer, intent(in) :: igroup"
  write(ilun,format)"  real(dp),intent(in) :: dens,Tp,Tr"
  write(ilun,format)"  "
  write(ilun,format)"  integer             :: ival,jval,kval"
  write(ilun,format)"  real(dp)            :: x,y,z,dx,dy,dz"
  write(ilun,format)"  real(dp)            :: x0,x1,y0,y1,z0,z1"
  write(ilun,format)"  real(dp)            :: c00,c01,c10,c11,c0,c1"
  write(ilun,format)"  real(dp)            :: rosseland_ana"
  write(ilun,format)"  "
  write(ilun,format)"  ! compute dust and gas opacities"
  write(ilun,format)"  x = log10(dens)"
  write(ilun,format)"  y = log10(Tp)"
  write(ilun,format)"  z = log10(Tr)"
  write(ilun,format)"  if(stellar_photon)then"
  write(ilun,format)"     if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) "
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1"
  write(ilun,format)"  jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1"
  write(ilun,format)"  kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1"
  write(ilun,format)"  "
  write(ilun,format)"  ! Perform tri-linear interpolation"
  write(ilun,format)"  "
  write(ilun,format)"  ! Compute coordinate deltas"
  write(ilun,format)"  x0 = x_opmesh(ival  )"
  write(ilun,format)"  x1 = x_opmesh(ival+1)"
  write(ilun,format)"  y0 = y_opmesh(jval  )"
  write(ilun,format)"  y1 = y_opmesh(jval+1)"
  write(ilun,format)"  z0 = z_opmesh(kval  )"
  write(ilun,format)"  z1 = z_opmesh(kval+1)"
  write(ilun,format)"  "
  write(ilun,format)"  dx = (x-x0)/(x1-x0)"
  write(ilun,format)"  dy = (y-y0)/(y1-y0)"
  write(ilun,format)"  dz = (z-z0)/(z1-z0)"
  write(ilun,format)"  "
  write(ilun,format)"  ! First linear interpolation along x"
  write(ilun,format)"  c00 = kappa_opmesh_r(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval  )*dx"
  write(ilun,format)"  c10 = kappa_opmesh_r(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval  )*dx"
  write(ilun,format)"  c01 = kappa_opmesh_r(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval+1)*dx"
  write(ilun,format)"  c11 = kappa_opmesh_r(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval+1)*dx"
  write(ilun,format)"  "
  write(ilun,format)"  ! Second linear interpolation along y"
  write(ilun,format)"  c0 = c00*(1.0_dp-dy) + c10*dy"
  write(ilun,format)"  c1 = c01*(1.0_dp-dy) + c11*dy"
  write(ilun,format)"  "
  write(ilun,format)"  ! Third linear interpolation along z"
  write(ilun,format)"  rosseland_ana = c0*(1.0_dp-dz) + c1*dz"
  write(ilun,format)"  "
  write(ilun,format)"  rosseland_ana = dens*10.0_dp**(rosseland_ana)"
  write(ilun,format)""
  write(ilun,format)"end function rosseland_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Function SCATTERING_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> This routine computes the scattering opacity kappa_s*rho"
  write(ilun,format)"!! as a function of density and temperature."
  write(ilun,format)"!! Units are supposed to be in cgs here (as in units.f90)"
  write(ilun,format)"!<"
  write(ilun,format)"function scattering_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use const"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer ,intent(in)    :: igroup"
  write(ilun,format)"  real(dp),intent(in)    :: dens,Tp,Tr"
  write(ilun,format)"  real(dp)               :: scattering_ana"
  write(ilun,format)"  "
  write(ilun,format)"  scattering_ana = zero"
  write(ilun,format)""
  write(ilun,format)"end function scattering_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Subroutine COMPUTE_INTEGRAL:"
  write(ilun,format)"!"
  write(ilun,format)"!> Computes integrals for Planck and Rosseland means between nu1 and nu2."
  write(ilun,format)"!<"
  write(ilun,format)"subroutine compute_integral(int1,int2,int3,int4,int5,int6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)""
  write(ilun,format)"  use amr_parameters, only : dp"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp), intent(inout) :: int1,int2,int3,int4,int5,int6"
  write(ilun,format)"  real(dp), intent(in   ) :: nu1,nu2,op1,op2,temp"
  write(ilun,format)"  real(dp)                :: BPlanck,Div_BPlanck"
  write(ilun,format)""
  write(ilun,format)"  int1 = int1 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp) * op1 + &"
  write(ilun,format)"                                           BPlanck(nu2,temp) * op2 )"
  write(ilun,format)"  int2 = int2 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp)       + &"
  write(ilun,format)"                                           BPlanck(nu2,temp)       )"
  write(ilun,format)"  int3 = int3 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp)       + &"
  write(ilun,format)"                                       Div_BPlanck(nu2,temp)       )"
  write(ilun,format)"  int4 = int4 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp) / op1 + &"
  write(ilun,format)"                                       Div_BPlanck(nu2,temp) / op2 )"
  write(ilun,format)"  int5 = int5 + 0.5_dp * (nu2-nu1) * ( op1 + op2 )"
  write(ilun,format)"  int6 = int6 +          (nu2-nu1)"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_integral"
  write(ilun,format)"../patch/collapse/read_hydro_params.f90"
  write(ilun,format)"subroutine read_hydro_params(nml_ok)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use const"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  use variables_X,ONLY:nvarchimie,nchimie,tchimie,&"
  write(ilun,format)"      &nminchimie,tminchimie,dnchimie,dtchimie"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Local variables  "
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  integer::i,j,idim,irad,nboundary_true=0,ht"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)::bound_type"
  write(ilun,format)"  real(dp)::ek_bound,em_bound,er_bound"
  write(ilun,format)"  real(dp)::radiation_source"
  write(ilun,format)"  character(len=2):: rad_trans_model='m1'"
  write(ilun,format)""
  write(ilun,format)"  integer::ii,jj,kk,ee,hh,gg,ie,ir,k,it"
  write(ilun,format)"  real(dp)::dummy,compute_db,d0"
  write(ilun,format)"  real(dp)::xx,yy,vv,ww,zz"
  write(ilun,format)"  real(dp)::dtemp1,Temp_new2,epsilon_n,eint_old,T0,temp_new,d_loc,eint_new,pi"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/init_params/filetype,initfile,multiple,nregion,region_type &"
  write(ilun,format)"       & ,x_center,y_center,z_center,aexp_ini &"
  write(ilun,format)"       & ,length_x,length_y,length_z,exp_region &"
  write(ilun,format)"       & ,d_region,u_region,v_region,w_region,p_region &"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"       & ,prad_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"       & ,E_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>8+NENER"
  write(ilun,format)"       & ,var_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,A_region,B_region,C_region &"
  write(ilun,format)"       & ,alpha,beta,crit,delta_rho,mass_c,rap,cont &"
  write(ilun,format)"       & ,ff_sct,ff_rt,ff_act,ff_vct,theta_mag,bb_test &"
  write(ilun,format)"       & ,contrast,Mach,uniform_bmag"
  write(ilun,format)"  namelist/hydro_params/gamma,courant_factor,smallr,smallc &"
  write(ilun,format)"       & ,niter_riemann,slope_type,slope_mag_type,switch_solv &"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"       & ,gamma_rad &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,pressure_fix,beta_fix,scheme,riemann,riemann2d &"
  write(ilun,format)"       & ,positivity_type"
  write(ilun,format)"  namelist/refine_params/x_refine,y_refine,z_refine,r_refine &"
  write(ilun,format)"       & ,a_refine,b_refine,exp_refine,jeans_refine,mass_cut_refine &"
  write(ilun,format)"       & ,iso_jeans,Tp_jeans &"
  write(ilun,format)"       & ,m_refine,mass_sph,err_grad_d,err_grad_p,err_grad_u &"
  write(ilun,format)"       & ,err_grad_A,err_grad_B,err_grad_C,err_grad_B2,err_grad_E &"
  write(ilun,format)"       & ,floor_d,floor_u,floor_p,ivar_refine,var_cut_refine &"
  write(ilun,format)"       & ,floor_A,floor_B,floor_C,floor_B2,floor_E &"
  write(ilun,format)"       & ,interpol_var,interpol_type,sink_refine,interpol_mag_type"
  write(ilun,format)"  namelist/boundary_params/nboundary,bound_type &"
  write(ilun,format)"       & ,ibound_min,ibound_max,jbound_min,jbound_max &"
  write(ilun,format)"       & ,kbound_min,kbound_max &"
  write(ilun,format)"       & ,d_bound,u_bound,v_bound,w_bound,p_bound &"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"       & ,prad_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"       & ,E_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>8+NENER"
  write(ilun,format)"       & ,var_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,A_bound,B_bound,C_bound,T_bound ,no_inflow"
  write(ilun,format)"  namelist/physics_params/cooling,haardt_madau,metal,isothermal,barotrop,eos &"
  write(ilun,format)"       & ,m_star,t_star,n_star,T2_star,g_star,del_star,eps_star,jeans_ncells &"
  write(ilun,format)"       & ,eta_sn,yield,rbubble,f_ek,ndebris,f_w,mass_gmc,kappa_IR &"
  write(ilun,format)"       & ,J21,a_spec,z_ave,z_reion,eta_mag,delayed_cooling &"
  write(ilun,format)"       & ,self_shielding,smbh,agn,B_ave,t_diss &"
  write(ilun,format)"!       & ,rsink_max,msink_max,merge_stars &"
  write(ilun,format)"       & ,units_density,units_time,units_length,neq_chem,ir_feedback,ir_eff &"
  write(ilun,format)"       & ,larson_lifetime,flux_accretion,t_diss &"
  write(ilun,format)"       & ,mu_gas,analytical_barotrop"
  write(ilun,format)"  namelist/radiation_params/grey_rad_transfer,dtdiff_params,dt_control &"
  write(ilun,format)"       & ,rosseland_params,planck_params,epsilon_diff,fld_limiter &"
  write(ilun,format)"       & ,freqs_in_Hz,read_groups,split_groups_log,extra_end_group  &"
  write(ilun,format)"       & ,numin,numax,Tr_floor,robin,rad_trans_model,min_optical_depth,rt_feedback &"
  write(ilun,format)"       & ,PMS_evol,Hosokawa_track,energy_fix,facc_star,facc_star_lum,valp_min,store_matrix,external_radiation_field &"
  write(ilun,format)"       & ,opacity_type,rad_trans_model,min_optical_depth &"
  write(ilun,format)"       & ,rt_feedback,PMS_evol,Hosokawa_track,energy_fix &"
  write(ilun,format)"       & ,facc_star,facc_star_lum,store_matrix &"
  write(ilun,format)"       & ,external_radiation_field,stellar_photon"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  namelist/nonidealmhd_params/nambipolar,gammaAD &"
  write(ilun,format)"       & ,nmagdiffu,etaMD,nhall,rHall,ntestDADM &"
  write(ilun,format)"       & ,coefad, nminitimestep, coefalfven,nmagdiffu2,nambipolar2,nu_sts,coefdtohm &"
  write(ilun,format)"       & ,rho_threshold,use_x1d,use_x2d,use_res"
  write(ilun,format)"  namelist/pseudovisco_params/nvisco,visco"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=init_params,END=101)"
  write(ilun,format)"  goto 102"
  write(ilun,format)"101 write(*,*)' You need to set up namelist &INIT_PARAMS in parameter file'"
  write(ilun,format)"  call clean_stop"
  write(ilun,format)"102 rewind(1)"
  write(ilun,format)"  if(nlevelmax>levelmin)read(1,NML=refine_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  if(hydro)read(1,NML=hydro_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"  if(FLD)read(1,NML=radiation_params)"
  write(ilun,format)"#endif"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=boundary_params,END=103)"
  write(ilun,format)"  simple_boundary=.true."
  write(ilun,format)"  goto 104"
  write(ilun,format)"103 simple_boundary=.false."
  write(ilun,format)"104 if(nboundary>MAXBOUND)then"
  write(ilun,format)"    write(*,*) 'Error: nboundary>MAXBOUND'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=physics_params,END=105)"
  write(ilun,format)"105 continue"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units (to be done after read physics_params with units_density...)"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  if(barotrop)fld=.false."
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set ischeme"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (scheme)"
  write(ilun,format)"  CASE ('muscl')"
  write(ilun,format)"    ischeme = 0"
  write(ilun,format)"  CASE ('induction')"
  write(ilun,format)"    ischeme = 1"
  write(ilun,format)""
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown scheme'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set iriemann"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (riemann)"
  write(ilun,format)"  CASE ('llf')"
  write(ilun,format)"    iriemann = 0"
  write(ilun,format)"  CASE ('roe')"
  write(ilun,format)"    iriemann = 1"
  write(ilun,format)"  CASE ('hll')"
  write(ilun,format)"    iriemann = 2"
  write(ilun,format)"  CASE ('hlld')"
  write(ilun,format)"    iriemann = 3"
  write(ilun,format)"  CASE ('upwind')"
  write(ilun,format)"    iriemann = 4"
  write(ilun,format)"  CASE ('hydro')"
  write(ilun,format)"    iriemann = 5"
  write(ilun,format)""
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown riemann solver'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set iriemann"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (riemann2d)"
  write(ilun,format)"  CASE ('llf')"
  write(ilun,format)"    iriemann2d = 0"
  write(ilun,format)"  CASE ('roe')"
  write(ilun,format)"    iriemann2d = 1"
  write(ilun,format)"  CASE ('upwind')"
  write(ilun,format)"    iriemann2d = 2"
  write(ilun,format)"  CASE ('hll')"
  write(ilun,format)"    iriemann2d = 3"
  write(ilun,format)"  CASE ('hlla')"
  write(ilun,format)"    iriemann2d = 4"
  write(ilun,format)"  CASE ('hlld')"
  write(ilun,format)"    iriemann2d = 5"
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown 2D riemann solver'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=nonidealmhd_params,END=106)"
  write(ilun,format)"106 continue"
  write(ilun,format)"  if((nambipolar.ne.0).and.(nambipolar.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nambipolar'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if((nmagdiffu.ne.0).and.(nmagdiffu.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nmagdiffu'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if((nhall.ne.0).and.(nhall.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nhall'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if((nmagdiffu.eq.1).and.(nmagdiffu2.eq.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nmagdiffu : choose one kind not both'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if((nambipolar.eq.1).and.(nambipolar2.eq.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nambipolar : choose one kind not both'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &"
  write(ilun,format)"      (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &"
  write(ilun,format)"      (nhall.eq.1) )then"
  write(ilun,format)"     use_nonideal_mhd = .true."
  write(ilun,format)"  else"
  write(ilun,format)"     use_nonideal_mhd = .false."
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  if(myid==1) then"
  write(ilun,format)"     write(*,*)'!!!!!!!!!!!!!!!  Non Ideal MHD   !!!!!!!!!!!!!!!!'"
  write(ilun,format)"     write(*,*)'Non ideal MHD parameters'"
  write(ilun,format)"     write(*,*)'Making a test ? Yes=1 No=0',ntestDADM"
  write(ilun,format)"     if(nambipolar.eq.1) then"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion switched ON'"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion coefficient',gammaAD"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion time coefficient',coefad"
  write(ilun,format)"        write(*,*)'Ionisation coefficient',coefionis"
  write(ilun,format)"        if(nminitimestep.eq.1) then"
  write(ilun,format)"           write(*,*)'Mini time step switched ON'"
  write(ilun,format)"           write(*,*)'Mini time step coefficient',coefalfven"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)'Mini time step switched OFF'"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nambipolar2==1) then"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion switched ON : subcylcing'"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion coefficient',gammaAD"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion time coefficient',coefad"
  write(ilun,format)"        write(*,*)'Ionisation coefficient',coefionis"
  write(ilun,format)"        if(nminitimestep.eq.1) then"
  write(ilun,format)"           write(*,*)'Mini time step switched ON'"
  write(ilun,format)"           write(*,*)'Mini time step coefficient',coefalfven"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)'Mini time step switched OFF'"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     if((nambipolar.eq.0) .and. (nambipolar2 == 0)) write(*,*)'Ambipolar diffusion switched OFF'"
  write(ilun,format)""
  write(ilun,format)"     if(nmagdiffu.eq.1)then"
  write(ilun,format)"        write(*,*)'Magnetic diffusion switched ON : multiple time stepping'"
  write(ilun,format)"        write(*,*)'Magnetic diffusion coefficient',etaMD"
  write(ilun,format)"        write(*,*)'Magnetic diffusion  time coefficient',coefohm"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nmagdiffu2.eq.1)then"
  write(ilun,format)"        write(*,*)'Magnetic diffusion switched ON : subcycling'"
  write(ilun,format)"        write(*,*)'Magnetic diffusion coefficient',etaMD"
  write(ilun,format)"        write(*,*)'Magnetic diffusion  time coefficient',coefohm"
  write(ilun,format)"     endif"
  write(ilun,format)"     if((nmagdiffu.eq.0).and.(nmagdiffu2.eq.0))write(*,*)'Magnetic diffusion switched OFF'"
  write(ilun,format)""
  write(ilun,format)"     if(nhall.eq.1)then"
  write(ilun,format)"        write(*,*)'Hall effect switched ON'"
  write(ilun,format)"        write(*,*)'Hall resistivity',rHall"
  write(ilun,format)"        write(*,*)'Hall effect time coefficient',coefhall"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nhall.eq.0)write(*,*)'Hall effect switched OFF'"
  write(ilun,format)""
  write(ilun,format)"    !if(change_solver.eq.1)then             ! change solver is always used in this version"
  write(ilun,format)"        write(*,*)'Solveur change when the time step becomes too small'"
  write(ilun,format)"        write(*,*)'switch_solv', switch_solv"
  write(ilun,format)"    !endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=pseudovisco_params,END=107)"
  write(ilun,format)"107 continue"
  write(ilun,format)"  if((nvisco.ne.0).and.(nvisco.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nvisco'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1) then"
  write(ilun,format)"     write(*,*)'!!!!!!!!! Pseudo Viscosity Parameters  !!!!!!!!!!'"
  write(ilun,format)"     if(nvisco.eq.1) then"
  write(ilun,format)"        write(*,*)'Pseudo viscosity switched ON'"
  write(ilun,format)"        write(*,*)'Pseudo viscosity coefficient',visco"
  write(ilun,format)"        write(*,*)'Pseudo viscosity time coefficient',coefvisco"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     if(nvisco.eq.0) then"
  write(ilun,format)"        write(*,*)'Pseudo viscosity switched OFF'"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if((nambipolar2.eq.1).or.(nmagdiffu2.eq.1))then"
  write(ilun,format)"     if(pressure_fix.eqv..false.) then"
  write(ilun,format)"        write(*,*)'STS needs pressure_fix=.true. to work....'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"#else"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=nonidealmhd_params,END=108)"
  write(ilun,format)"108 continue"
  write(ilun,format)"  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &"
  write(ilun,format)"       (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &"
  write(ilun,format)"       (nhall.eq.1) )then"
  write(ilun,format)"     if (myid==1) write(*,*)'You must recompile with NIMHD=1 for non-ideal MHD...'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"  ! Initialize multigroup"
  write(ilun,format)"  allocate(nu_min_hz(1:ngrp),nu_max_hz(1:ngrp),nu_min_ev(1:ngrp),nu_max_ev(1:ngrp))"
  write(ilun,format)"  call create_groups"
  write(ilun,format)"  call tabulate_art4"
  write(ilun,format)"  call read_omegas"
  write(ilun,format)"  if(myid==1 .and. grey_rad_transfer .and. ngrp .gt.1) then"
  write(ilun,format)"     print*,'Warning: Grey Radiation Transfer with NRAD>1'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  scale_E0 = aR*(Tr_floor**4)"
  write(ilun,format)"  P_cal = scale_E0 / (scale_d * scale_v**2)"
  write(ilun,format)"  C_cal = clight / scale_v"
  write(ilun,format)"  is_radiative_energy = .false."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  ! Set i_fld_limiter"
  write(ilun,format)"  i_fld_limiter=i_fld_limiter_nolim"
  write(ilun,format)"  if(fld_limiter=='levermore') i_fld_limiter=i_fld_limiter_levermore"
  write(ilun,format)"  if(fld_limiter=='minerbo')  i_fld_limiter=i_fld_limiter_minerbo"
  write(ilun,format)"  ! Index array for radiative variables and temperature"
  write(ilun,format)"  ! Needed in M1 because temperature is stored in uold(:,nvar)"
  write(ilun,format)"  do irad = 1,nvar_bicg"
  write(ilun,format)"     ind_bicg (irad) = firstindex_er+irad"
  write(ilun,format)"     norm_bicg(irad) = P_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  ind_trad(1) = nvar"
  write(ilun,format)"  norm_trad(1) = Tr_floor"
  write(ilun,format)"  do irad = 2,nvar_trad"
  write(ilun,format)"     ind_trad(irad) = firstindex_er-1+irad"
  write(ilun,format)"     norm_trad(irad) = P_cal"
  write(ilun,format)"     is_radiative_energy(irad) = .true."
  write(ilun,format)"  enddo"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  ! Set radiative transfer model"
  write(ilun,format)"  select case(rad_trans_model)"
  write(ilun,format)"  case('P1','p1')"
  write(ilun,format)"     irad_trans_model = irad_trans_model_p1"
  write(ilun,format)"  case('M1','m1')"
  write(ilun,format)"     irad_trans_model = irad_trans_model_m1"
  write(ilun,format)"  case default"
  write(ilun,format)"     if(myid==1) write(*,*) 'unknown radiative transfer model: '//rad_trans_model"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end select"
  write(ilun,format)"  call compute_valp"
  write(ilun,format)"  ! Index array for radiative variables and temperature"
  write(ilun,format)"  ! Needed in M1 because temperature is stored in uold(:,nvar)"
  write(ilun,format)"  ind_bicg(1) = nvar"
  write(ilun,format)"  norm_bicg(1) = Tr_floor"
  write(ilun,format)"  do irad = 2,nvar_bicg"
  write(ilun,format)"     ind_bicg(irad) = firstindex_er-1+irad"
  write(ilun,format)"     norm_bicg(irad) = P_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  do irad = ngrp+2,nvar_bicg"
  write(ilun,format)"     norm_bicg(irad) = norm_bicg(irad)*C_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  ind_trad=ind_bicg"
  write(ilun,format)"  norm_trad=norm_bicg"
  write(ilun,format)"  is_radiative_energy(2:ngrp+1) = .true."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Make sure virtual boundaries are expanded to "
  write(ilun,format)"  ! account for staggered mesh representation"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  nexpand_bound=2"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for star formation"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(t_star>0)then"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  else if(eps_star>0)then"
  write(ilun,format)"     t_star=0.1635449*(n_star/0.1)**(-0.5)/eps_star"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for metal"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(metal.and.nvar<(ndim+6))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: metals need nvar >= ndim+6'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify hydro_parameters.f90 and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for non-thermal energies"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"  if(nvar<(8+nent))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: non-thermal energy need nvar >= 8+nent'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify NENER and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for radiative variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  if(nvar<(8+nener))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: radiative energies need nvar >= 8+nent+ngrp'"
  write(ilun,format)"#else"
  write(ilun,format)"  if(nvar<(8+nener+nfr))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: radiative variables need nvar >= 8+nent+ngrp+nfr'"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify NENER, NGRP and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! This section deals with hydro boundary conditions"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if (simple_boundary)then"
  write(ilun,format)""
  write(ilun,format)"     ! Compute new coarse grid boundaries"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           nx=nx+1"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              icoarse_min=icoarse_min+1"
  write(ilun,format)"              icoarse_max=icoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ny=ny+1"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jcoarse_min=jcoarse_min+1"
  write(ilun,format)"              jcoarse_max=jcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           nz=nz+1"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kcoarse_min=kcoarse_min+1"
  write(ilun,format)"              kcoarse_max=kcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute boundary geometry"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_min+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=1"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=11"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=21"
  write(ilun,format)"           else"
  write(ilun,format)"              ibound_min(i)=icoarse_max+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=2"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=12"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=22"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>1)jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           if(ndim>1)jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_min+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=3"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=13"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=23"
  write(ilun,format)"           else"
  write(ilun,format)"              jbound_min(i)=jcoarse_max+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=4"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=14"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=24"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_min+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=5"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=15"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=25"
  write(ilun,format)"           else"
  write(ilun,format)"              kbound_min(i)=kcoarse_max+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=6"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=16"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=26"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        ! Check for errors"
  write(ilun,format)"        if( (ibound_min(i)<0.or.ibound_max(i)>(nx-1)) .and. (ndim>0) .and.bound_type(i)>0 )then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along X direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (jbound_min(i)<0.or.jbound_max(i)>(ny-1)) .and. (ndim>1) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Y direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (kbound_min(i)<0.or.kbound_max(i)>(nz-1)) .and. (ndim>2) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Z direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  nboundary=nboundary_true"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Compute boundary conservative variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  do i=1,nboundary"
  write(ilun,format)"     ! Do imposed BC for radiative transfer"
  write(ilun,format)"     d0=compute_db()"
  write(ilun,format)"     d_bound(i)=d0"
  write(ilun,format)"     T_bound(i)=Tr_floor"
  write(ilun,format)"     P_bound(i)=T_bound(i)*d_bound(i)*kb/(mu_gas*mH*scale_v**2)"
  write(ilun,format)"     "
  write(ilun,format)"     boundary_var(i,1)=MAX(d_bound(i),smallr)"
  write(ilun,format)"     boundary_var(i,2)=d_bound(i)*u_bound(i)"
  write(ilun,format)"     boundary_var(i,3)=d_bound(i)*v_bound(i)"
  write(ilun,format)"     boundary_var(i,4)=d_bound(i)*w_bound(i)"
  write(ilun,format)"     boundary_var(i,6)=A_bound(i)"
  write(ilun,format)"     boundary_var(i,7)=B_bound(i)"
  write(ilun,format)"     boundary_var(i,8)=C_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+1)=A_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+2)=B_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+3)=C_bound(i)"
  write(ilun,format)""
  write(ilun,format)"     er_bound=0.0D0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"     do j=1,nent"
  write(ilun,format)"        boundary_var(i,firstindex_er+j)=prad_bound(i,j)"
  write(ilun,format)"        er_bound=er_bound+boundary_var(i,8+j)/(gamma_rad(j)-1.0d0)"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"     !     T_bound(i)=P_bound(i)*mu_gas*mH/kb/d_bound(i) *scale_v**2"
  write(ilun,format)"     call temperature_eos(d_bound(i),P_bound(i)/(gamma-1.0d0),T_bound(i),ht)"
  write(ilun,format)"     do j=1,ngrp"
  write(ilun,format)"        boundary_var(i,firstindex_er+j)=radiation_source(T_bound(i),j)/(scale_d*scale_v**2)"
  write(ilun,format)"        er_bound=er_bound+boundary_var(i,firstindex_er+j)"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"        !Radiative fluxes"
  write(ilun,format)"                   boundary_var(i,firstindex_er+  ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fx_bound(i,j)"
  write(ilun,format)"        if(ndim>1) boundary_var(i,firstindex_er+2*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fy_bound(i,j)"
  write(ilun,format)"        if(ndim>2) boundary_var(i,firstindex_er+3*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fz_bound(i,j)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ek_bound=0.5d0*d_bound(i)*(u_bound(i)**2+v_bound(i)**2+w_bound(i)**2)"
  write(ilun,format)"     em_bound=0.5d0*(A_bound(i)**2+B_bound(i)**2+C_bound(i)**2)"
  write(ilun,format)"     boundary_var(i,5)=ek_bound+em_bound+er_bound+P_bound(i)/(gamma-1.0d0)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Rearrange level dependent arrays"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  do i=nlevelmax,levelmin,-1"
  write(ilun,format)"     jeans_refine(i)=jeans_refine(i-levelmin+1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,levelmin-1"
  write(ilun,format)"     jeans_refine(i)=-1.0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Sort out passive variable indices"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  inener=9 ! MUST BE THIS VALUE !!! RT variable"
  write(ilun,format)"  imetal=firstindex_pscal+1"
  write(ilun,format)"  lastindex_pscal=nvar"
  write(ilun,format)"  if(energy_fix)lastindex_pscal=nvar-1"
  write(ilun,format)"  idelay=imetal"
  write(ilun,format)"  if(metal)idelay=imetal+1"
  write(ilun,format)"  ixion=idelay"
  write(ilun,format)"  if(delayed_cooling)ixion=idelay+1"
  write(ilun,format)"  ichem=ixion"
  write(ilun,format)"  if(aton)ichem=ixion+1"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Set magnetic slope limiters"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  if (slope_mag_type == -1) then"
  write(ilun,format)"    slope_mag_type = slope_type"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (interpol_mag_type == -1) then"
  write(ilun,format)"    interpol_mag_type = interpol_type"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  ! Read resistivity tables for non-ideal MHD"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  if(use_nonideal_mhd)then"
  write(ilun,format)"     if(use_res==1)then"
  write(ilun,format)"        open(10,file='res_sig.dat', status='old')"
  write(ilun,format)"        read(10,*) nchimie"
  write(ilun,format)"        allocate(resistivite_chimie_res(8,nchimie))"
  write(ilun,format)"        do i=1,nchimie"
  write(ilun,format)"           read(10,*)resistivite_chimie_res(:,i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        close(10)"
  write(ilun,format)"        rho_threshold=max(rho_threshold,resistivite_chimie_res(1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units"
  write(ilun,format)"        resistivite_chimie_res(7,:)=resistivite_chimie_res(7,:)*clight**2/(4.d0*acos(-1.))"
  write(ilun,format)"        resistivite_chimie_res(6,:)=1.43d-7**2/(&"
  write(ilun,format)"        &max(resistivite_chimie_res(6,:)*((1.0d0-tanh(resistivite_chimie_res(1,:)/5.0d13))),1.e-36)&"
  write(ilun,format)"        &*3.d-16*sqrt(resistivite_chimie_res(1,:))*(2.34d-24**1.5)*clight**2)"
  write(ilun,format)"        !     open(1010,file='res_sig_v.dat', status='new')"
  write(ilun,format)"        nminchimie=(resistivite_chimie_res(1,1))"
  write(ilun,format)"        dnchimie=(log10(resistivite_chimie_res(1,nchimie))-log10(resistivite_chimie_res(1,1)))/&"
  write(ilun,format)"                 &(nchimie-1)"
  write(ilun,format)"!                 print*, dnchimie,17.d0/35.d0"
  write(ilun,format)"        !     do i=1,nchimie"
  write(ilun,format)"        !     write(1010,*)resistivite_chimie(1,i),resistivite_chimie(6,i)"
  write(ilun,format)"        !  end do"
  write(ilun,format)"        !     close(1010)"
  write(ilun,format)"        !     stop"
  write(ilun,format)"     else if(use_x2d==1)then"
  write(ilun,format)"        open(42,file='resnh.dat', status='old')"
  write(ilun,format)"        read(42,*) nchimie, tchimie, nvarchimie"
  write(ilun,format)"        read(42,*)"
  write(ilun,format)"        read(42,*)"
  write(ilun,format)"        allocate(resistivite_chimie_x(-1:nvarchimie,nchimie,tchimie))"
  write(ilun,format)"        do i=1,tchimie"
  write(ilun,format)"           do j=1,nchimie"
  write(ilun,format)"              read(42,*)resistivite_chimie_x(0:nvarchimie,j,i),dummy,dummy,dummy,dummy,resistivite_chimie_x(-1,j,i)"
  write(ilun,format)"!              print *, resistivite_chimie_x(:,j,i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           read(42,*)"
  write(ilun,format)"        end do"
  write(ilun,format)"        close(42)"
  write(ilun,format)"        rho_threshold=max(rho_threshold,resistivite_chimie_x(0,1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units"
  write(ilun,format)"        nminchimie=(resistivite_chimie_x(0,1,1))"
  write(ilun,format)"        dnchimie=(log10(resistivite_chimie_x(0,nchimie,1))-log10(resistivite_chimie_x(0,1,1)))/&"
  write(ilun,format)"                 &(nchimie-1)"
  write(ilun,format)"!                 print*, dnchimie,15.d0/50.d0"
  write(ilun,format)"        tminchimie=(resistivite_chimie_x(-1,1,1))"
  write(ilun,format)"        dtchimie=(log10(resistivite_chimie_x(-1,1,tchimie))-log10(resistivite_chimie_x(-1,1,1)))/&"
  write(ilun,format)"                 &(tchimie-1)"
  write(ilun,format)"!                 print*, dtchimie,3.d0/50.d0"
  write(ilun,format)"        close(333)"
  write(ilun,format)"        call rq"
  write(ilun,format)"        call nimhd_3dtable"
  write(ilun,format)"     else if(((use_x2d .ne. 1) .and. (use_res .ne. 1)) .or. &"
  write(ilun,format)"            &((use_x2d .eq. 0) .and. (use_res .eq. 0)) )then"
  write(ilun,format)"        print*, 'must choose an input for abundances or resistivities'"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(barotrop)fld=.false."
  write(ilun,format)""
  write(ilun,format)"  if(barotrop .and. (.not. analytical_barotrop))then"
  write(ilun,format)"     open(101,file='barotropic_eos.dat', status='old')"
  write(ilun,format)"     read(101,*)nrho_barotrop,rhomin_barotrop,rhomax_barotrop,drho_barotrop"
  write(ilun,format)"     allocate(rho_barotrop(nrho_barotrop))"
  write(ilun,format)"     allocate(temp_barotrop(nrho_barotrop))"
  write(ilun,format)"     do i=1,nrho_barotrop"
  write(ilun,format)"        read(101,*)rho_barotrop(i),temp_barotrop(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(101)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(eos)then"
  write(ilun,format)"  "
  write(ilun,format)"     !--------------------------------"
  write(ilun,format)"     ! Read eos tables"
  write(ilun,format)"     !--------------------------------"
  write(ilun,format)"!      open(14,file='verif.dat')"
  write(ilun,format)"     open(10,file='tab_eos.dat',status='old',form='unformatted')"
  write(ilun,format)"     read(10) nRho,nEnergy"
  write(ilun,format)"     read(10) rhomin,rhomax,emin,Emax,yHe"
  write(ilun,format)"     "
  write(ilun,format)"     allocate(Rho_eos(nRho,nEnergy),Ener_eos(nRho,nEnergy),Temp_eos(nRho,nEnergy),P_eos(nRho,nEnergy))"
  write(ilun,format)"     allocate(  Cs_eos(nRho,nEnergy),S_eos(nRho,nEnergy),  xH_eos(nRho,nEnergy), xH2_eos(nRho,nEnergy)                  )"
  write(ilun,format)"     allocate(xHe_eos(nRho,nEnergy),xHep_eos(nRho,nEnergy),Cv_eos(nRho,nEnergy)                                       )"
  write(ilun,format)"     !inversion de la table eos"
  write(ilun,format)"     nTemp=nEnergy"
  write(ilun,format)"     allocate(eint_eos(nRho,nTemp))"
  write(ilun,format)"     "
  write(ilun,format)"     read(10)  rho_eos"
  write(ilun,format)"     read(10) Ener_eos"
  write(ilun,format)"     read(10) Temp_eos"
  write(ilun,format)"     read(10)    P_eos"
  write(ilun,format)"     read(10)    S_eos"
  write(ilun,format)"     read(10)   Cs_eos"
  write(ilun,format)"     read(10)   xH_eos"
  write(ilun,format)"     read(10)  xH2_eos"
  write(ilun,format)"     read(10)  xHe_eos"
  write(ilun,format)"     read(10) xHep_eos"
  write(ilun,format)"     close(10)"
  write(ilun,format)"     "
  write(ilun,format)"     rho_eos(:,:) = log10(rho_eos(:,:))"
  write(ilun,format)"     ener_eos(:,:) = log10(ener_eos(:,:))"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (P_eos(ir,ie) .eq. 0.0d0) then"
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = P_eos(ir,ie+1) * P_eos(ir,ie-1) *  P_eos(ir-1,ie) * P_eos(ir+1,ie)"
  write(ilun,format)"                 yy = P_eos(ir+1,ie+1) * P_eos(ir+1,ie-1) *  P_eos(ir-1,ie-1) * P_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = P_eos(ir,ie+2) * P_eos(ir,ie-2) *  P_eos(ir-2,ie) * P_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = P_eos(ir+3,ie+3) * P_eos(ir-3,ie-3) *  P_eos(ir-3,ie+3) * P_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+1) + P_eos(ir,ie-1) + P_eos(ir-1,ie) + P_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+1,ie+1) + P_eos(ir+1,ie-1) + P_eos(ir-1,ie+1)+P_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+2) + P_eos(ir,ie-2) + P_eos(ir-2,ie) + P_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+3,ie+3) + P_eos(ir+3,ie-3) + P_eos(ir-3,ie+3)+P_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous P_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (Cs_eos(ir,ie) .eq. 0.0d0) then           "
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = Cs_eos(ir,ie+1) * Cs_eos(ir,ie-1) *  Cs_eos(ir-1,ie) * Cs_eos(ir+1,ie)"
  write(ilun,format)"                 yy = Cs_eos(ir+1,ie+1) * Cs_eos(ir+1,ie-1) *  Cs_eos(ir-1,ie-1) * Cs_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = Cs_eos(ir,ie+2) * Cs_eos(ir,ie-2) *  Cs_eos(ir-2,ie) * Cs_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = Cs_eos(ir+3,ie+3) * Cs_eos(ir-3,ie-3) *  Cs_eos(ir-3,ie+3) * Cs_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+1) + Cs_eos(ir,ie-1) + Cs_eos(ir-1,ie) + Cs_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+1,ie+1) + Cs_eos(ir+1,ie-1) + Cs_eos(ir-1,ie+1)+Cs_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+2) + Cs_eos(ir,ie-2) + Cs_eos(ir-2,ie) + Cs_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+3,ie+3) + Cs_eos(ir+3,ie-3) + Cs_eos(ir-3,ie+3)+Cs_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous Cs_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (Temp_eos(ir,ie) .eq. 0.0d0) then           "
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = Temp_eos(ir,ie+1) * Temp_eos(ir,ie-1) *  Temp_eos(ir-1,ie) * Temp_eos(ir+1,ie)"
  write(ilun,format)"                 yy = Temp_eos(ir+1,ie+1) * Temp_eos(ir+1,ie-1) *  Temp_eos(ir-1,ie-1) * Temp_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = Temp_eos(ir,ie+2) * Temp_eos(ir,ie-2) *  Temp_eos(ir-2,ie) * Temp_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = Temp_eos(ir+3,ie+3) * Temp_eos(ir-3,ie-3) *  Temp_eos(ir-3,ie+3) * Temp_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+1)+Temp_eos(ir,ie-1)+Temp_eos(ir-1,ie)+Temp_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+1,ie+1)+Temp_eos(ir+1,ie-1)+Temp_eos(ir-1,ie+1)+Temp_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+2)+Temp_eos(ir,ie-2)+Temp_eos(ir-2,ie)+Temp_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+3,ie+3)+Temp_eos(ir+3,ie-3)+Temp_eos(ir-3,ie+3)+Temp_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous Temp_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     Tmin=3.0d0"
  write(ilun,format)"     Tmax=1.0d5"
  write(ilun,format)"     dtemp1 =(log10(Tmax) - log10(Tmin))/ntemp"
  write(ilun,format)"     eint_eos(:,:)=0.0d0"
  write(ilun,format)"     do ir=2,nRho-1"
  write(ilun,format)"        do it=1,ntemp"
  write(ilun,format)"           d_loc = (10.**rho_eos(ir,1))"
  write(ilun,format)"           T0 = 10.**(log10(Tmin) + (it-1.0d0)*dtemp1)"
  write(ilun,format)"           "
  write(ilun,format)"           eint_old = d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0))"
  write(ilun,format)"           if (it >1) then"
  write(ilun,format)"              eint_old = max(d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0)),eint_eos(ir,it-1))"
  write(ilun,format)"           end if"
  write(ilun,format)"           "
  write(ilun,format)"           epsilon_n = 1.0d0"
  write(ilun,format)"           "
  write(ilun,format)"           do ii=1,1000"
  write(ilun,format)"              call temperature_eos(d_loc/scale_d,eint_old/(scale_d*scale_v**2),temp_new,ht)"
  write(ilun,format)"              if (ht==1) then"
  write(ilun,format)"                 eint_old=0.d0"
  write(ilun,format)"                 exit"
  write(ilun,format)"              end if"
  write(ilun,format)"              call temperature_eos(d_loc/scale_d,eint_old*1.001_dp/(scale_d*scale_v**2),temp_new2,ht)"
  write(ilun,format)"              if (ht==1) then"
  write(ilun,format)"                 eint_old=0.d0"
  write(ilun,format)"                 exit"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              if(abs(Temp_new2-Temp_new) .ne.0)then"
  write(ilun,format)"                 eint_new = eint_old - (Temp_new-T0)/((Temp_new2-Temp_new)/(0.001*eint_old))"
  write(ilun,format)"              else"
  write(ilun,format)"                 eint_new = eint_old"
  write(ilun,format)"              endif"
  write(ilun,format)"              epsilon_n = abs(eint_new - eint_old)/eint_old"
  write(ilun,format)"              eint_old = eint_new"
  write(ilun,format)"              if  (abs(epsilon_n) .lt. 1.d-4) then"
  write(ilun,format)"                 exit"
  write(ilun,format)"              else if (ii==1000) then"
  write(ilun,format)"                 print*, 'newton for e(rho,T) did not converge at ', log10(d_loc),log10(T0)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"           eint_eos(ir,it) = eint_old "
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"     "
  write(ilun,format)"     Cv_eos(:,:)=0.0d0"
  write(ilun,format)"     "
  write(ilun,format)"     do  ir=2,nRho-1"
  write(ilun,format)"        do  ie=2,nEnergy-1"
  write(ilun,format)"           d_loc = (10.**rho_eos(ir,1))"
  write(ilun,format)"           T0 = 10.**(ener_eos(ir,ie))"
  write(ilun,format)"           "
  write(ilun,format)"           call temperature_eos(d_loc/scale_d,(T0-0.001_dp*T0)/(scale_d*scale_v**2),temp_new,ht)"
  write(ilun,format)"           call temperature_eos(d_loc/scale_d,(T0+0.001_dp*T0)/(scale_d*scale_v**2),temp_new2,ht)"
  write(ilun,format)"           "
  write(ilun,format)"           if((temp_new2-temp_new) .ne. 0.0_dp)then"
  write(ilun,format)"              Cv_eos(ir,ie)=(0.002_dp*T0)/(temp_new2-temp_new)"
  write(ilun,format)"           else"
  write(ilun,format)"              Cv_eos(ir,ie) = 1.0_dp"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     Cv_eos(:,nEnergy)=Cv_eos(:,nEnergy-1)"
  write(ilun,format)"     "
  write(ilun,format)"     if (myid == 1) print*, 'ok pour le bouchage'"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Multigroup opacities initialization"
  write(ilun,format)"  if(fld)then"
  write(ilun,format)"     if((opacity_type == 'grey') .and. (ngrp > 1) .and. (.not.stellar_photon))then"
  write(ilun,format)"        if(myid == 1)then"
  write(ilun,format)"           write(*,*) 'WARNING! Trying to use grey opacity table with ngrp =',ngrp"
  write(ilun,format)"           write(*,*) 'Switching to multigroup opacities'"
  write(ilun,format)"        endif"
  write(ilun,format)"        opacity_type = 'multigroup'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call init_opacities"
  write(ilun,format)"  end if"
  write(ilun,format)" "
  write(ilun,format)"  if(PMS_evol .and. rt_feedback .and. Hosokawa_track)then"
  write(ilun,format)"     open(101,file='Hosokawa_track.dat', status='old')"
  write(ilun,format)"     read(101,*)nmdot_PMS,nm_PMS,ndata_PMS"
  write(ilun,format)"     allocate(nb_ligne_PMS(nmdot_PMS))"
  write(ilun,format)"     allocate(data_PMS(nmdot_PMS,nm_PMS,ndata_PMS))"
  write(ilun,format)"     read(101,*)nb_ligne_PMS(1),nb_ligne_PMS(2),nb_ligne_PMS(3),nb_ligne_PMS(4),nb_ligne_PMS(5)"
  write(ilun,format)"     do i=1,nmdot_PMS"
  write(ilun,format)"        do j=1,nm_PMS"
  write(ilun,format)"           read(101,*)data_PMS(i,j,1),data_PMS(i,j,2),data_PMS(i,j,3),data_PMS(i,j,4) ! mdot,mass,luminosity,radius"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(101)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_hydro_params"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"!   Modification of original codes written by David H. Bailey    "
  write(ilun,format)"!   This subroutine computes ddb(i) = dda(i)+ddb(i)"
  write(ilun,format)"subroutine DDPDD (dda, ddb, len, itype)"
  write(ilun,format)"use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp):: e, t1, t2"
  write(ilun,format)"  integer i, len, itype"
  write(ilun,format)"!  complex*16:: dda(len), ddb(len)"
  write(ilun,format)"  complex*16:: dda, ddb"
  write(ilun,format)"!  print*,dda,ddb"
  write(ilun,format)"  do i = 1, len"
  write(ilun,format)"     !   Compute dda + ddb using Knuth's trick."
  write(ilun,format)"     t1 = real(dda) + real(ddb)"
  write(ilun,format)"     e = t1 - real(dda)"
  write(ilun,format)"!!      t1 = real(dda(i)) + real(ddb(i))"
  write(ilun,format)"!!      e = t1 - real(dda(i))"
  write(ilun,format)"     t2 = ((real(ddb) - e) + (real(dda) - (t1 - e)))&"
  write(ilun,format)"     &     +imag(dda) + imag(ddb)"
  write(ilun,format)"!!      t2 = ((real(ddb(i)) - e) + (real(dda(i)) - (t1 - e)))&"
  write(ilun,format)"!!      &     +imag(dda(i)) + imag(ddb(i))"
  write(ilun,format)"!!  !    print*,t1,t2"
  write(ilun,format)"     !   The result is t1 + t2, after normalization."
  write(ilun,format)"!!      ddb(i) = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1) )"
  write(ilun,format)"     ddb = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1),dp)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)"  return"
  write(ilun,format)"end subroutine DDPDD"
  write(ilun,format)"../patch/collapse/units.f90"
  write(ilun,format)"subroutine units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  use units_commons, only : scale_kappa,scale_m"
  write(ilun,format)"  use radiation_parameters, only : mu_gas"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_t,scale_v,scale_d,scale_l"
  write(ilun,format)"  real(dp)::pc"
  write(ilun,format)"  "
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! Conversion factors from user units into cgs units"
  write(ilun,format)"  ! For gravity runs, make sure that G=1 in user units."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  !code units are: G=1, rho cm^-3, x pc"
  write(ilun,format)"  pc = 3.08e18_dp"
  write(ilun,format)""
  write(ilun,format)"  ! scale_d converts mass density from user units into g/cc"
  write(ilun,format)"  !scale_d = units_density"
  write(ilun,format)"  !if(cosmo) scale_d = omega_m * rhoc *(h0/100.)**2 / aexp**3"
  write(ilun,format)"  !calculate the initial density"
  write(ilun,format)"  scale_d = mu_gas*mH"
  write(ilun,format)""
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  !scale_t = units_time"
  write(ilun,format)"  !if(cosmo) scale_t = aexp**2 / (h0*1d5/3.08d24)"
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  scale_t = 1.0_dp/sqrt(Grav*scale_d)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_l converts distance from user units into cm"
  write(ilun,format)"  !scale_l = units_length"
  write(ilun,format)"  !if(cosmo) scale_l = aexp * boxlen_ini * 3.08d24 / (h0/100)"
  write(ilun,format)"  !calculate the initial cloud radius"
  write(ilun,format)"  scale_l = pc"
  write(ilun,format)""
  write(ilun,format)"  ! scale_v converts velocity in user units into cm/s"
  write(ilun,format)"  scale_v = scale_l / scale_t"
  write(ilun,format)""
  write(ilun,format)"  ! scale_T2 converts (P/rho) in user unit into (T/mu) in Kelvin"
  write(ilun,format)"  !kT = 10. * kB  / G / pc^2 / mpart^2"
  write(ilun,format)"  scale_T2 = mu_gas**2 * mH**2 * pc**2 * Grav / kb"
  write(ilun,format)""
  write(ilun,format)"  ! scale_nH converts rho in user units into nH in H/cc"
  write(ilun,format)"!  scale_nH = X/(mH*mu) * scale_d"
  write(ilun,format)"  scale_nH = 1.0_dp ! X/(mH) * scale_d"
  write(ilun,format)"  "
  write(ilun,format)"  scale_kappa = 1.0_dp/scale_l"
  write(ilun,format)"  "
  write(ilun,format)"  scale_m = scale_d*scale_l**3"
  write(ilun,format)"  "
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  if(ntestDADM.eq.1) then"
  write(ilun,format)"      scale_d = 1.0_dp"
  write(ilun,format)"      scale_l = 1.0_dp"
  write(ilun,format)"      scale_v = 1.d0"
  write(ilun,format)"      scale_t = 1.0_dp"
  write(ilun,format)"  end if"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine units"
  write(ilun,format)""
  close(ilun)
end subroutine output_patch
